// Code partially copyright Edd Dawson 2007
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.


#include "libmesh/libmesh_config.h"
#include "libmesh/print_trace.h"
#include "libmesh/libmesh.h"

#include <unistd.h>  // needed for getpid()
#include <fstream>
#include <sstream>
#include <string>
#include <cstdio> // std::remove
#include <cstdlib> // std::system
#include <sys/types.h> // pid_t

#if defined(LIBMESH_HAVE_GCC_ABI_DEMANGLE) && defined(LIBMESH_HAVE_GLIBC_BACKTRACE)

#include <execinfo.h>
#include <cxxabi.h>

namespace libMesh
{

std::string process_trace(const char *name)
{
  std::string fullname = name;
  std::string saved_begin, saved_end;
  size_t namestart, nameend;

  /**
   * The Apple backtrace function returns more information than the Linux version.
   * We need to pass only the function name to the demangler or it won't decode it for us.
   *
   * lineno: stackframeno                 address functionname + offset
   */

#ifdef __APPLE__
  namestart = fullname.find("0x");
  if (namestart != std::string::npos)
    {
      namestart = fullname.find(' ', namestart) + 1;
      saved_begin = fullname.substr(0, namestart);
    }
  else
    namestart = 0;
  nameend = fullname.find('+');
  if (nameend == std::string::npos ||
      nameend <= namestart)
    nameend = fullname.size();
  else
    {
      nameend -= 1;
      saved_end = fullname.substr(nameend, fullname.length());
    }
#else
  namestart = fullname.find('(');
  if (namestart == std::string::npos)
    return fullname;
  else
    namestart++;
  nameend = fullname.find('+');
  if (nameend == std::string::npos ||
      nameend <= namestart)
    return fullname;
#endif

  std::string type_name = fullname.substr(namestart, nameend - namestart);

  // Try to demangle now
  return saved_begin + demangle(type_name.c_str()) + saved_end;
}


std::string demangle(const char *name)
{
  int status = 0;
  std::string ret = name;

  // Actually do the demangling
  char *demangled_name = abi::__cxa_demangle(name, 0, 0, &status);

  // If demangling returns non-NULL, save the result in a string.
  if (demangled_name)
    ret = demangled_name;

  // According to cxxabi.h docs, the caller is responsible for
  // deallocating memory.
  std::free(demangled_name);

  return ret;
}



bool gdb_backtrace(std::ostream &out_stream)
{
  // Eventual return value, true if gdb succeeds, false otherwise.
  bool success = true;

  // The system() call does not allow us to redirect the output to a
  // C++ ostream, so we redirect gdb's output to a (known) temporary
  // file, and then send output that to the user's stream.
  char temp_file[] = "temp_print_trace.XXXXXX";
  int fd = mkstemp(temp_file);

  // If mkstemp fails, we failed.
  if (fd == -1)
    success = false;
  else
    {
      // Run gdb using a system() call, redirecting the output to our
      // temporary file.
      pid_t this_pid = getpid();
      std::ostringstream command;
      command << "gdb -p " << this_pid << " -batch -ex bt 2>/dev/null 1>" << temp_file;
      std::system(command.str().c_str());

      // If we can open the temp_file and it is not empty, we'll
      // assume that gdb worked, so copy the file's contents to the
      // user's requested stream.  This rdbuf() thing is apparently
      // how you do this... otherwise, report failure.
      std::ifstream fin(temp_file);
      if (fin && (fin.peek() != std::ifstream::traits_type::eof()))
        out_stream << fin.rdbuf();
      else
        success = false;
    }

  // Clean up the temporary file, regardless of whether it was opened successfully.
  std::remove(temp_file);

  return success;
}



void print_trace(std::ostream &out_stream)
{
  // First try a GDB backtrace.  They are better than what you get
  // from calling backtrace() because you don't have to do any
  // demangling, and they include line numbers!  If the GDB backtrace
  // fails, for example if your system does not have GDB, fall back to
  // calling backtrace().
  bool gdb_worked = gdb_backtrace(out_stream);

  if (!gdb_worked)
    {
      void *addresses[40];
      char **strings;

      int size = backtrace(addresses, 40);
      strings = backtrace_symbols(addresses, size);
      out_stream << "Stack frames: " << size << std::endl;
      for(int i = 0; i < size; i++)
        out_stream << i << ": " << process_trace(strings[i]) << std::endl;
      std::free(strings);
    }
}

} // namespace libMesh

#else

namespace libMesh
{
void print_trace(std::ostream &) {}

std::string demangle(const char *name) { return std::string(name); }
}

#endif


namespace libMesh
{
void write_traceout()
{
#ifdef LIBMESH_ENABLE_TRACEFILES
  std::stringstream outname;
  outname << "traceout_" << static_cast<std::size_t>(libMesh::global_processor_id()) << '_' << getpid() << ".txt";
  std::ofstream traceout(outname.str().c_str(), std::ofstream::app);
  libMesh::print_trace(traceout);
#endif
}
}
