Index: include/base/dof_map.h
===================================================================
--- include/base/dof_map.h	(revision 6518)
+++ include/base/dof_map.h	(working copy)
@@ -309,13 +309,24 @@
     return *_n_oz;
   }
 
+  // /**
+  //  * Add an unknown of order \p order and finite element type
+  //  * \p type to the system of equations.
+  //  */
+  // void add_variable (const Variable &var);
+
   /**
-   * Add an unknown of order \p order and finite element type
+   * Add a group of unknowns of order \p order and finite element type
    * \p type to the system of equations.
    */
-  void add_variable (const Variable &var);
+  void add_variable_group (const VariableGroup &var_group);
 
   /**
+   * @returns the \p VariableGroup description object for group \p g.
+   */
+  const VariableGroup& variable_group (const unsigned int c) const;
+
+  /**
    * @returns the variable description object for variable \p c.
    */
   const Variable& variable (const unsigned int c) const;
@@ -326,23 +337,41 @@
   Order variable_order (const unsigned int c) const;
 
   /**
+   * @returns the approximation order for \p VariableGroup \p vg.
+   */
+  Order variable_group_order (const unsigned int vg) const;
+
+  /**
    * @returns the finite element type for variable \p c.
    */
   const FEType& variable_type (const unsigned int c) const;
 
   /**
+   * @returns the finite element type for \p VariableGroup \p vg.
+   */
+  const FEType& variable_group_type (const unsigned int vg) const;
+
+  /**
    * Returns the number of variables in the global solution vector. Defaults
    * to 1, should be 1 for a scalar equation, 3 for 2D incompressible Navier
    * Stokes (u,v,p), etc...
    */
+  unsigned int n_variable_groups() const
+  { return _variable_groups.size(); }
+
+  /**
+   * Returns the number of variables in the global solution vector. Defaults
+   * to 1, should be 1 for a scalar equation, 3 for 2D incompressible Navier
+   * Stokes (u,v,p), etc...
+   */
   unsigned int n_variables() const
   { return _variables.size(); }
 
   /**
    * @returns the total number of degrees of freedom in the problem.
    */
-
   unsigned int n_dofs() const { return _n_dfs; }
+  
   /**
    * @returns the number of SCALAR dofs.
    */
@@ -399,27 +428,6 @@
 #endif //LIBMESH_ENABLE_AMR
 
   /**
-   * Returns the first local degree of freedom index for variable \p var.
-   */
-  unsigned int variable_first_local_dof (const unsigned int var) const
-  {
-    libmesh_assert_less ((var+1), _var_first_local_df.size());
-    libmesh_assert_not_equal_to (_var_first_local_df[var], DofObject::invalid_id);
-    return _var_first_local_df[var];
-  }
-
-  /**
-   * Returns (one past) the last local degree of freedom index for variable \p var.
-   * Analogous to the end() member function of STL containers.
-   */
-  unsigned int variable_last_local_dof (const unsigned int var) const
-  {
-    libmesh_assert_less ((var+1), _var_first_local_df.size());
-    libmesh_assert_not_equal_to (_var_first_local_df[var+1], DofObject::invalid_id);
-    return _var_first_local_df[var+1];
-  }
-
-  /**
    * Fills the vector \p di with the global degree of freedom indices
    * for the element. If no variable number is specified then all
    * variables are returned.
@@ -979,14 +987,18 @@
   void add_constraints_to_send_list();
 
 #endif // LIBMESH_ENABLE_CONSTRAINTS
-
-
+  
   /**
    * The finite element type for each variable.
    */
   std::vector<Variable> _variables;
 
   /**
+   * The finite element type for each variable.
+   */
+  std::vector<VariableGroup> _variable_groups;
+
+  /**
    * The number of the system we manage DOFs for.
    */
   const unsigned int _sys_number;
@@ -1009,18 +1021,13 @@
   std::vector<unsigned int> _end_df;
 
   /**
-   * The first local DOF index for each variable in the \p System.
-   */
-  std::vector<unsigned int> _var_first_local_df;
-
-  /**
    * A list containing all the global DOF indicies that affect the
    * solution on my subdomain.
    */
   std::vector<unsigned int> _send_list;
 
   /**
-   *
+   * Funtion object to call to add extra entries to the sparsity pattern
    */
   AugmentSparsityPattern *_augment_sparsity_pattern;
 
@@ -1037,7 +1044,7 @@
   void * _extra_sparsity_context;
 
   /**
-   * 
+   * Function object to call to add extra entries to the send list
    */
   AugmentSendList *_augment_send_list;
 
@@ -1145,14 +1152,75 @@
 
 // ------------------------------------------------------------
 // Dof Map inline member functions
-
 inline
 unsigned int DofMap::sys_number() const
 {
   return _sys_number;
 }
 
+
+
 inline
+const VariableGroup & DofMap::variable_group (const unsigned int g) const
+{
+  libmesh_assert_less (g, _variable_groups.size());
+
+  return _variable_groups[g];
+}
+
+
+
+inline
+const Variable & DofMap::variable (const unsigned int c) const
+{
+  libmesh_assert_less (c, _variables.size());
+
+  return _variables[c];
+}
+
+
+
+inline
+Order DofMap::variable_order (const unsigned int c) const
+{
+  libmesh_assert_less (c, _variables.size());
+
+  return _variables[c].type().order;
+}
+
+
+
+inline
+Order DofMap::variable_group_order (const unsigned int vg) const
+{
+  libmesh_assert_less (vg, _variable_groups.size());
+
+  return _variable_groups[vg].type().order;
+}
+
+
+
+inline
+const FEType& DofMap::variable_type (const unsigned int c) const
+{
+  libmesh_assert_less (c, _variables.size());
+
+  return _variables[c].type();
+}
+
+
+
+inline
+const FEType& DofMap::variable_group_type (const unsigned int vg) const
+{
+  libmesh_assert_less (vg, _variable_groups.size());
+
+  return _variable_groups[vg].type();
+}
+
+
+
+inline
 bool DofMap::is_constrained_node (const Node*
 #ifdef LIBMESH_ENABLE_NODE_CONSTRAINTS
 node
Index: include/base/dof_object.h
===================================================================
--- include/base/dof_object.h	(revision 6518)
+++ include/base/dof_object.h	(working copy)
@@ -67,6 +67,7 @@
 
   /**
    * Copy-constructor.
+
    */
   DofObject (const DofObject&);
 
@@ -196,18 +197,33 @@
   void add_system ();
 
   /**
-   * @returns the number of variables associated with system \p s
-   * for this \p DofObject
+   * @returns the number of \p VariableGroup variable groups
+   * associated with system \p s for this \p DofObject
    */
+  unsigned int n_var_groups(const unsigned int s) const;
+
+  /**
+   * @returns the number of \p Variable variables associated
+   * with \p VariableGroup \p vg in system \p s for this \p DofObject
+   */
+  unsigned int n_vars(const unsigned int s,
+		      const unsigned int vg) const;
+
+  /**
+   * @returns the number of \p Variable variables associated
+   * with system \p s for this \p DofObject
+   */
   unsigned int n_vars(const unsigned int s) const;
 
   /**
-   * Sets number of variables associated with system \p s for this
-   * \p DofObject.  Has the effect of setting the number of components
-   * to 0 even when called even with (nvars == this->n_vars(s)).
+   * Sets number of variables in each group associated with system \p s for this
+   * \p DofObject. Implicit in this is salso setting the number of \p VariableGroup
+   * variable groups for the system.
+   * Has the effect of setting the number of components
+   * to 0 even when called even with (nvg == this->n_var_groups(s)).
    */
-  void set_n_vars(const unsigned int s,
-		  const unsigned int nvars);
+  void set_n_vars_per_group(const unsigned int s,
+			    const std::vector<unsigned int> &nvpg);
 
   /**
    * @returns the number of components for variable \p var
@@ -222,7 +238,19 @@
 		      const unsigned int var) const;
 
   /**
-   * Sets the number of components for variable \p var
+   * @returns the number of components for \p VariableGroup \p vg
+   * of system \p s associated with this \p DofObject.
+   * For example, the \p HIERARCHIC shape functions may
+   * have @e multiple dof's associated with @e one node.  Another
+   * example is the \p MONOMIALs, where only the elements
+   * hold the dof's, but for the different spatial directions,
+   * and orders, see \p FE.
+   */
+  unsigned int n_comp_group(const unsigned int s,
+			    const unsigned int vg) const;
+
+  /**
+   * Sets the number of components for \p Variable \p var
    * of system \p s associated with this \p DofObject
    */
   void set_n_comp(const unsigned int s,
@@ -230,6 +258,14 @@
 		  const unsigned int ncomp);
 
   /**
+   * Sets the number of components for \p VariableGroup \p vg
+   * of system \p s associated with this \p DofObject
+   */
+  void set_n_comp_group(const unsigned int s,
+			const unsigned int vg,
+			const unsigned int ncomp);
+
+  /**
    * @returns the global degree of freedom number for variable \p var,
    * component \p comp for system \p s associated with this \p DofObject
    */
@@ -253,13 +289,23 @@
   bool has_dofs(const unsigned int s=libMesh::invalid_uint) const;
 
   /**
-   * Implemented in Elem and Node.
+   * \p VariableGroup DOF indices are indexed as
+   * id = base + var_in_vg*ncomp + comp
+   * This method allows for direct access to the base.
    */
-//  virtual bool operator==(const DofObject& ) const
-//  { libmesh_error(); return false; }
+  void set_vg_dof_base(const unsigned int s,
+		       const unsigned int vg,
+		       const unsigned int db);
 
-
   /**
+   * \p VariableGroup DOF indices are indexed as
+   * id = base + var_in_vg*ncomp + comp
+   * This method allows for direct access to the base.
+   */
+  unsigned int vg_dof_base(const unsigned int s,
+			   const unsigned int vg) const;
+  
+  /**
    * An invaild \p id to distinguish an uninitialized \p DofObject
    */
   static const unsigned int invalid_id = libMesh::invalid_uint;
@@ -296,10 +342,29 @@
    */
   void pack_indexing(std::back_insert_iterator<std::vector<int> > target) const;
 
+  /**
+   * Print our buffer for debugging.
+   */
+  void debug_buffer () const;
+
 private:
 
+  /**
+   * Utility function - for variable \p var in system \p s, figure out what
+   * variable group it lives in.
+   */
+  unsigned int var_to_vg (const unsigned int s,
+			  const unsigned int var) const;
 
   /**
+   * Utility function - for variable \p var in system \p s, figure out what
+   * variable group it lives in.
+   */
+  unsigned int system_var_to_vg_var (const unsigned int s,
+				     const unsigned int vg,
+				     const unsigned int var) const;
+  
+  /**
    * The \p id of the \p DofObject
    */
   unsigned int _id;
@@ -318,29 +383,61 @@
   /**
    * DOF index information.  This is packed into a contiguous buffer of the following format:
    *
-   * [ns end_0 end_1 ... end_{ns-1} (nc_0 idx_0 nc_1 idx_1 ... nc_nv idx_nv)_0 (nc_0 idx_0 nc_1 idx_1 ... nc_nv idx_nv)_1 ... (nc_0 idx_0 nc_1 idx_1 ... nc_nv idx_nv)_ns ]
+   * [ns end_0 end_1 ... end_{ns-1} (ncv_0 idx_0 ncv_1 idx_1 ... ncv_nv idx_nv)_0 (ncv_0 idx_0 ncv_1 idx_1 ... ncv_nv idx_nv)_1 ... (ncv_0 idx_0 ncv_1 idx_1 ... ncv_nv idx_nv)_ns ]
    *
-   * where 'end_s' is the index past the end of the variable storage for system \p s.
+   * where 'end_s' is the index past the end of the variable group storage for system \p s.
    * Note that we specifically do not store the end for the last system - this always _idx_buf.size().
    *
-   * Specifically, consider the case of 4 systems, with 3, 0, 1, 2 DOFs respectively.  The _idx_buf then looks like
+   * Specifically, consider the case of 4 systems, with 3, 0, 1, 2 variable groups, respectively.  The _idx_buf then looks like:
+   \verbatim
+    [4 10 10 12 () (ncv_0 idx_0 ncv_1 idx_1 ncv_2 idx_2) () (ncv_0 idx_0) (ncv_0 idx_0 ncv_1 idx_1)]
+    [0  1  2  3         4     5     6     7     8     9         10    11      12    13    14    15]
+
+   \endverbatim
+   * The ending index is then given by
+   \verbatim
+    end_s = _idx_buf.size(), s == (ns-1),
+          = _idx_buf[s+1]    otherwise.
+   \endverbatim
+   * The starting indices are not specifically stored, but rather inferred as follows:
    *
-   * [4 10 10 12 () (nc_0 idx_0 nc_1 idx_1 nc_2 idx_2) () (nc_0 idx_0) (nc_0 idx_0 nc_1 idx_1)]
-   * [0  1  2  3        4     5    6     7    8     9        10    11     12    13   14    15]
+   * start_s = _idx_buf[s];
+
+   * Now, the defining characteristic of the \p VariableGroup is that it supports
+   * an arbitrary number of variables of the same type.  At the \p DofObject level, what
+   * that means is that each \p Variable in the \p VariableGroup will have the same number
+   * of nonzero components, and they can all be indexed from the same base number.  We use this
+   * information in the ncv_# and idx_# entries as follows:
+   * 
+   * ncv_# = n_vars*ncv_magic + n_comp      for variable group #
+   * idx_# = base_offset                    for variable group #
    *
-   * The ending index is then given by
+   * the DOF index for a particular component c of variable v within that group is then given by
    *
-   * end_s = _idx_buf.size(), s == (ns-1),
-   *       = _idx_buf[s+1]    otherwise.
+   *  idx_var = idx_# + n_comp*v + c
    *
-   * The starting indices are not specifically stored, but rather inferred as follows:
-   *
-   * start_s = _idx_buf[s];
+   * note there is a subtlety here - "variable v within that group" usually means nothing to the
+   * user. This class is either indexed with variable group numbers, or variable numbers counted
+   * *within the system*. So for a system with 2 variable groups, 4 and 8 variables each,
+   * the 5th variable in the system is the 1st variable in 2nd variable group.
+   * (Now of course 0-base everything...  but you get the idea.)
    */
-  typedef std::vector<unsigned int> index_buffer_t;
+  typedef unsigned int index_t;
+  typedef std::vector<index_t> index_buffer_t;
   index_buffer_t _idx_buf;
 
   /**
+   * Above we introduced the chimera ncv, which is a hybrid of the form   
+   * ncv = ncv_magic*nv + nc
+   * where nv are the number of identical variables of a given type,
+   * and nc is the number of components for this set of variables.
+   *
+   * It is hoped that by setting this to a power of two, an optimizing compiler
+   * will recgnize later that  #/ncv_magic is simply a bitshift
+   */
+  static const index_t ncv_magic = 256; // = 2^8, in case we want to manually bitshift
+  
+  /**
    * The starting index for system \p s.
    */
   unsigned int start_idx(const unsigned int s) const;
@@ -389,15 +486,15 @@
   if (sys_num >= this->n_systems())
     {
       for (unsigned int s=0; s<this->n_systems(); s++)
-        for (unsigned int v=0; v<this->n_vars(s); v++)
-	  if (this->n_comp(s,v))
-	    this->set_dof_number(s,v,0,invalid_id);
+        for (unsigned int vg=0; vg<this->n_var_groups(s); vg++)
+	  if (this->n_comp_group(s,vg))
+	    this->set_vg_dof_base(s,vg,invalid_id);
     }
   // ...otherwise invalidate the dofs for all systems
   else
-    for (unsigned int v=0; v<this->n_vars(sys_num); v++)
-      if (this->n_comp(sys_num,v))
-        this->set_dof_number(sys_num,v,0,invalid_id);
+    for (unsigned int vg=0; vg<this->n_var_groups(sys_num); vg++)
+      if (this->n_comp_group(sys_num,vg))
+        this->set_vg_dof_base(sys_num,vg,invalid_id);
 }
 
 
@@ -527,7 +624,7 @@
 
 
 inline
-unsigned int DofObject::n_vars(const unsigned int s) const
+unsigned int DofObject::n_var_groups(const unsigned int s) const
 {
   libmesh_assert_less (s, this->n_systems());
 
@@ -536,31 +633,66 @@
 
 
 
+inline
+unsigned int DofObject::n_vars(const unsigned int s,
+			       const unsigned int vg) const
+{
+  libmesh_assert_less (s,  this->n_systems());
+  libmesh_assert_less (vg, this->n_var_groups(s));
+  
+  const unsigned int start_idx_sys = this->start_idx(s);
+  
+  libmesh_assert_less ((start_idx_sys + 2*vg), _idx_buf.size());
 
+  return (_idx_buf[start_idx_sys + 2*vg] / ncv_magic);
+}
+
+
+
 inline
+unsigned int DofObject::n_vars(const unsigned int s) const
+{
+  libmesh_assert_less (s, this->n_systems());
+
+  const unsigned int nvg = this->n_var_groups(s);
+    
+  unsigned int val=0;
+
+  for (unsigned int vg=0; vg<nvg; vg++)
+    val += this->n_vars(s,vg);
+
+  return val;
+}
+
+
+
+
+inline
 unsigned int DofObject::n_comp(const unsigned int s,
 			       const unsigned int var) const
 {
-  libmesh_assert_less (s, this->n_systems());
+  libmesh_assert_less (s,   this->n_systems());
   libmesh_assert_less (var, this->n_vars(s));
 
-# ifdef DEBUG
-  // Does this ever happen?  I doubt it... 3/7/2003 (BSK)
-  if (var >= this->n_vars(s))
-    {
-      libMesh::err << "s=" << s << ", var=" << var << std::endl
-		    << "this->n_vars(s)=" << this->n_vars(s) << std::endl
-		    << "this->n_systems()=" << this->n_systems() << std::endl;
-      libmesh_error();
-    }
-# endif
+  return this->n_comp_group(s,this->var_to_vg(s,var));
+}
 
+
+
+
+inline
+unsigned int DofObject::n_comp_group(const unsigned int s,
+				     const unsigned int vg) const
+{
+  libmesh_assert_less (s,  this->n_systems());
+  libmesh_assert_less (vg, this->n_var_groups(s));
+
   const unsigned int
     start_idx_sys = this->start_idx(s);
 
-  libmesh_assert_less ((start_idx_sys + 2*var), _idx_buf.size());
+  libmesh_assert_less ((start_idx_sys + 2*vg), _idx_buf.size());
 
-  return _idx_buf[start_idx_sys + 2*var];
+  return (_idx_buf[start_idx_sys + 2*vg] % ncv_magic);
 }
 
 
@@ -570,17 +702,18 @@
 				   const unsigned int var,
 				   const unsigned int comp) const
 {
-  libmesh_assert_less (s, this->n_systems());
-  libmesh_assert_less (var, this->n_vars(s));
+  libmesh_assert_less (s,    this->n_systems());
+  libmesh_assert_less (var,  this->n_vars(s));
   libmesh_assert_less (comp, this->n_comp(s,var));
 
   const unsigned int
+    vg            = this->var_to_vg(s,var),
     start_idx_sys = this->start_idx(s);
 
-  libmesh_assert_less ((start_idx_sys + 2*var + 1), _idx_buf.size());
+  libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf.size());
 
   const unsigned int
-    base_idx = _idx_buf[start_idx_sys + 2*var + 1];
+    base_idx = _idx_buf[start_idx_sys + 2*vg + 1];
 
   // if the first component is invalid, they
   // are all invalid
@@ -590,7 +723,13 @@
   // otherwise the index is the first component
   // index augemented by the component number
   else
-    return (base_idx + comp);
+    {
+      const unsigned int
+	ncg = this->n_comp_group(s,vg),
+	vig = this->system_var_to_vg_var(s,vg,var);
+
+      return (base_idx + vig*ncg + comp);
+    }
 }
 
 
@@ -639,6 +778,87 @@
 }
 
 
+
+inline
+void DofObject::set_vg_dof_base(const unsigned int s,
+				const unsigned int vg,
+				const unsigned int db)
+{
+  libmesh_assert_less (s,  this->n_systems());
+  libmesh_assert_less (vg, this->n_var_groups(s));
+
+  const unsigned int
+    start_idx_sys = this->start_idx(s);
+
+  libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf.size());
+
+  _idx_buf[start_idx_sys + 2*vg + 1] = db;
+
+  libmesh_assert_equal_to (this->vg_dof_base(s,vg), db);
+}
+
+
+
+inline
+unsigned int DofObject::vg_dof_base(const unsigned int s,
+				    const unsigned int vg) const
+{
+  libmesh_assert_less (s,  this->n_systems());
+  libmesh_assert_less (vg, this->n_var_groups(s));
+
+  const unsigned int
+    start_idx_sys = this->start_idx(s);
+
+  libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf.size());
+
+// #ifdef DEBUG
+//   std::cout << " [ ";
+//   for (unsigned int i=0; i<_idx_buf.size(); i++)
+//     std::cout << _idx_buf[i] << " ";
+//   std::cout << "]\n";
+// #endif
+
+  return _idx_buf[start_idx_sys + 2*vg + 1];
+}
+
+
+
+inline
+unsigned int DofObject::var_to_vg (const unsigned int s,
+				   const unsigned int var) const
+{
+  const unsigned int
+    nvg = this->n_var_groups(s);
+
+  for (unsigned int vg=0, vg_end=0; vg<nvg; vg++)
+    {
+      vg_end += this->n_vars(s,vg);
+      if (var < vg_end) return vg;
+    }
+
+  // we should never get here
+  libmesh_error();
+  return 0;
+}
+
+
+
+inline
+unsigned int DofObject::system_var_to_vg_var (const unsigned int s,
+					      const unsigned int vg,
+					      const unsigned int var) const
+{
+  unsigned int accumulated_sum=0;
+  
+  for (unsigned int vgc=0; vgc<vg; vgc++)
+    accumulated_sum += this->n_vars(s,vg);
+  
+  libmesh_assert_less_equal (accumulated_sum, var);
+  
+  return (var - accumulated_sum);
+}
+
+
 } // namespace libMesh
 
 
Index: include/base/variable.h
===================================================================
--- include/base/variable.h	(revision 6518)
+++ include/base/variable.h	(working copy)
@@ -19,12 +19,14 @@
 #define __variable_h__
 
 // Local Includes
+#include "libmesh/libmesh_common.h"
 #include "libmesh/fe_type.h"
 #include "libmesh/id_types.h"
 
 // C++ includes
 #include <set>
 #include <string>
+#include <vector>
 
 namespace libMesh {
 
@@ -109,7 +111,7 @@
    * empty \p _active_subdomains container as active everywhere, i.e.
    * for all subdomains.
    */
-  bool active_on_subdomain (const subdomain_id_type sid) const
+  bool active_on_subdomain (subdomain_id_type sid) const
   { return (_active_subdomains.empty() || _active_subdomains.count(sid));  }
 
   /**
@@ -126,7 +128,7 @@
   const std::set<subdomain_id_type> & active_subdomains() const
   { return _active_subdomains; }
 
-private:
+protected:
   std::string             _name;
   unsigned int            _number;
   unsigned int            _first_scalar_number;
@@ -134,6 +136,114 @@
   std::set<subdomain_id_type> _active_subdomains;
 };
 
+
+
+/**
+ * This class defines a logically grouped set of variables in
+ * the system.  \p VariableGroup is appropriate for representing
+ * several unknowns in the problem that are all approximated
+ * with the same finite element approximation family and
+ * (optionally) a list of subdomains to which the
+ * variables are restricted.
+ */
+class VariableGroup : public Variable
+{
+public:
+  /**
+   * Constructor.  Omits the subdomain mapping, hence this
+   * constructor creates a variable which is active on
+   * all subdomains.
+   */
+  VariableGroup (const std::vector<std::string> &var_names,
+		 const unsigned int var_number,
+		 const unsigned int first_scalar_number,
+		 const FEType &var_type) :
+    Variable ("var_group",
+	      var_number,
+	      first_scalar_number,
+	      var_type),
+    _names(var_names)
+  {}
+
+   
+  /**
+   * Constructor.  Takes a set which contains the subdomain
+   * indices for which this variable is active.
+   */
+  VariableGroup (const std::vector<std::string> &var_names,
+		 const unsigned int var_number,
+		 const unsigned int first_scalar_number,
+		 const FEType &var_type,
+		 const std::set<subdomain_id_type> &var_active_subdomains) :
+     
+    Variable ("var_group",
+	      var_number,
+	      first_scalar_number,
+	      var_type,
+	      var_active_subdomains),
+    _names(var_names)
+  {}
+
+  /**
+   * The number of variables in this \p VariableGroup
+   */
+  unsigned int n_variables () const
+  { return _names.size(); }
+
+  /**
+   * Construct a \p Variable object for an individual member
+   * of our group.
+   */
+  Variable variable (unsigned int v) const
+  {
+    libmesh_assert_less (v, this->n_variables());
+    return Variable (this->name(v),
+		     this->number(v),
+		     this->first_scalar_number(v),
+		     this->type(),
+		     this->active_subdomains());
+  }
+
+  /**
+   * Support vg(v) - returns a \p Variable for v.
+   */
+  Variable operator() (unsigned int v) const
+  { return this->variable(v); }
+  
+  /**
+   * Arbitrary, user-specified name of the variable.
+   */
+  const std::string & name(unsigned int v) const
+  {
+    libmesh_assert_less (v, this->n_variables());
+    return _names[v];
+  }
+
+  /**
+   * The rank of this variable in the system.
+   */
+  unsigned int number(unsigned int v) const
+  {
+    libmesh_assert_less (v, this->n_variables());
+    return _number + v;
+  }
+
+  /**
+   * The index of the first scalar component of this variable in the
+   * system.
+   */
+  unsigned int first_scalar_number(unsigned int v) const
+  {
+    libmesh_assert_less (v, this->n_variables());
+    if ((this->type().family == SCALAR) &&
+	(this->n_variables() > 1)) libmesh_error(); // [BSK] I am not yet sure what this means!
+    return _first_scalar_number;
+  }
+
+protected:
+  std::vector<std::string> _names;
+};
+  
 } // namespace libMesh
 
 #endif // #define __variable_h__
Index: include/systems/system.h
===================================================================
--- include/systems/system.h	(revision 6518)
+++ include/systems/system.h	(working copy)
@@ -952,6 +952,11 @@
   unsigned int n_vars() const;
 
   /**
+   * @returns the number of \p VariableGroup variable groups in the system
+   */
+  unsigned int n_variable_groups() const;
+
+  /**
    * @returns the total number of scalar components in the system's
    * variables.  This will equal \p n_vars() in the case of all
    * scalar-valued variables.
@@ -1006,11 +1011,34 @@
 			     const std::set<subdomain_id_type> * const active_subdomains = NULL);
 
   /**
+   * Adds the variable \p var to the list of variables
+   * for this system.  Returns the index number for the new variable.
+   */
+  unsigned int add_variables (const std::vector<std::string> &vars,
+			      const FEType& type,
+			      const std::set<subdomain_id_type> * const active_subdomains = NULL);
+  
+  /**
+   * Adds the variable \p var to the list of variables
+   * for this system.  Same as before, but assumes \p LAGRANGE
+   * as default value for \p FEType.family.
+   */
+  unsigned int add_variables (const std::vector<std::string> &vars,
+			      const Order order = FIRST,
+			      const FEFamily = LAGRANGE,
+			      const std::set<subdomain_id_type> * const active_subdomains = NULL);
+
+  /**
    * Return a constant reference to \p Variable \p var.
    */
   const Variable & variable (unsigned int var) const;
 
   /**
+   * Return a constant reference to \p VariableGroup \p vg.
+   */
+  const VariableGroup & variable_group (unsigned int vg) const;
+
+  /**
    * @returns true if a variable named \p var exists in this System
    */
   bool has_variable(const std::string& var) const;
@@ -1631,11 +1659,16 @@
   const unsigned int _sys_number;
 
   /**
-   * The \p Variables in this \p System.
+   * The \p Variable in this \p System.
    */
   std::vector<Variable> _variables;
 
   /**
+   * The \p VariableGroup in this \p System.
+   */
+  std::vector<VariableGroup> _variable_groups;
+
+  /**
    * The variable numbers corresponding to user-specified
    * names, useful for name-based lookups.
    */
@@ -1797,6 +1830,14 @@
 
 
 inline
+unsigned int System::n_variable_groups() const
+{
+  return _variable_groups.size();
+}
+
+
+
+inline
 unsigned int System::n_components() const
 {
   if (_variables.empty())
@@ -1819,6 +1860,16 @@
 
 
 inline
+const VariableGroup & System::variable_group (const unsigned int vg) const
+{
+  libmesh_assert_less (vg, _variable_groups.size());
+
+  return _variable_groups[vg];
+}
+
+
+
+inline
 const std::string & System::variable_name (const unsigned int i) const
 {
   libmesh_assert_less (i, _variables.size());
Index: src/base/dof_map.C
===================================================================
--- src/base/dof_map.C	(revision 6518)
+++ src/base/dof_map.C	(working copy)
@@ -128,11 +128,11 @@
 DofMap::DofMap(const unsigned int number) :
   _dof_coupling(NULL),
   _variables(),
+  _variable_groups(),
   _sys_number(number),
   _matrices(),
   _first_df(),
   _end_df(),
-  _var_first_local_df(),
   _send_list(),
   _augment_sparsity_pattern(NULL),
   _extra_sparsity_function(NULL),
@@ -192,40 +192,24 @@
 
 
 
-void DofMap::add_variable (const Variable &var)
-{
-  _variables.push_back (var);
-}
+// void DofMap::add_variable (const Variable &var)
+// {
+//   libmesh_error();
+//   _variables.push_back (var);
+// }
 
 
 
-const Variable & DofMap::variable (const unsigned int c) const
+void DofMap::add_variable_group (const VariableGroup &var_group)
 {
-  libmesh_assert_less (c, _variables.size());
-
-  return _variables[c];
+  _variable_groups.push_back(var_group);
+  
+  for (unsigned int var=0; var<var_group.n_variables(); var++)    
+    _variables.push_back (var_group(var));
 }
 
 
 
-Order DofMap::variable_order (const unsigned int c) const
-{
-  libmesh_assert_less (c, _variables.size());
-
-  return _variables[c].type().order;
-}
-
-
-
-const FEType& DofMap::variable_type (const unsigned int c) const
-{
-  libmesh_assert_less (c, _variables.size());
-
-  return _variables[c].type();
-}
-
-
-
 void DofMap::attach_matrix (SparseMatrix<Number>& matrix)
 {
   parallel_only();
@@ -436,10 +420,17 @@
 
   START_LOG("reinit()", "DofMap");
 
-  //this->clear();
+  const unsigned int
+    sys_num      = this->sys_number(),
+    n_var_groups = this->n_variable_groups();
 
-  const unsigned int n_var = this->n_variables();
-
+  // The DofObjects need to know how many variable groups we have, and
+  // how many variables there are in each group.
+  std::vector<unsigned int> n_vars_per_group; /**/ n_vars_per_group.reserve (n_var_groups);
+  
+  for (unsigned int vg=0; vg<n_var_groups; vg++)
+    n_vars_per_group.push_back (this->variable_group(vg).n_variables());
+  
 #ifdef LIBMESH_ENABLE_AMR
 
   //------------------------------------------------------------
@@ -486,13 +477,13 @@
 	    Node* node = elem->get_node(n);
 
 	    if (node->old_dof_object == NULL)
-	      if (node->has_dofs(this->sys_number()))
+	      if (node->has_dofs(sys_num))
 		node->set_old_dof_object();
 	  }
 
 	libmesh_assert (!elem->old_dof_object);
 
-	if (elem->has_dofs(this->sys_number()))
+	if (elem->has_dofs(sys_num))
 	  elem->set_old_dof_object();
       }
   }
@@ -510,14 +501,14 @@
     const MeshBase::node_iterator node_end = mesh.nodes_end();
 
     for ( ; node_it != node_end; ++node_it)
-      (*node_it)->set_n_vars(this->sys_number(),n_var);
+      (*node_it)->set_n_vars_per_group(sys_num, n_vars_per_group);
 
     // All the elements
     MeshBase::element_iterator       elem_it  = mesh.elements_begin();
     const MeshBase::element_iterator elem_end = mesh.elements_end();
 
     for ( ; elem_it != elem_end; ++elem_it)
-      (*elem_it)->set_n_vars(this->sys_number(),n_var);
+      (*elem_it)->set_n_vars_per_group(sys_num, n_vars_per_group);
   }
 
 
@@ -526,18 +517,20 @@
 
   //------------------------------------------------------------
   // Next allocate space for the DOF indices
-  for (unsigned int var=0; var<this->n_variables(); var++)
+  for (unsigned int vg=0; vg<n_var_groups; vg++)
     {
-      const Variable &var_description =	this->variable(var);
-      const FEType& base_fe_type              = this->variable_type(var);
+      const VariableGroup &vg_description = this->variable_group(vg);
+      
+      const unsigned int n_var_in_group = vg_description.n_variables();
+      const FEType& base_fe_type        = vg_description.type();
 
       // Don't need to loop over elements for a SCALAR variable
       // Just increment _n_SCALAR_dofs
       if(base_fe_type.family == SCALAR)
-      {
-        this->_n_SCALAR_dofs += base_fe_type.order;
-        continue;
-      }
+	{
+	  this->_n_SCALAR_dofs += base_fe_type.order*n_var_in_group;
+	  continue;
+	}
 
       // This should be constant even on p-refined elements
       const bool extra_hanging_dofs =
@@ -554,13 +547,13 @@
 	  libmesh_assert(elem);
 
 	  // Skip the numbering if this variable is
-	  // not active on this element's subdoman
-	  if (!var_description.active_on_subdomain(elem->subdomain_id()))
+	  // not active on this element's subdomain
+	  if (!vg_description.active_on_subdomain(elem->subdomain_id()))
 	    continue;
 
 	  const ElemType type = elem->type();
           const unsigned int dim = elem->dim();
-
+	  
           FEType fe_type = base_fe_type;
 
 #ifdef LIBMESH_ENABLE_AMR
@@ -585,7 +578,7 @@
 
                   libmesh_error();
                 }
-
+	      
               libMesh::err
                 << "WARNING: Finite element "
                 << Utility::enum_to_string(base_fe_type.family)
@@ -611,7 +604,7 @@
 	      if (elem->is_vertex(n))
 	        {
 	          const unsigned int old_node_dofs =
-	            node->n_comp(this->sys_number(), var);
+	            node->n_comp_group(sys_num, vg);
 
 		  const unsigned int vertex_dofs =
 		    std::max(FEInterface::n_dofs_at_node(dim, fe_type,
@@ -621,12 +614,23 @@
 		  // Some discontinuous FEs have no vertex dofs
 		  if (vertex_dofs > old_node_dofs)
 		    {
-		      node->set_n_comp(this->sys_number(), var,
-				       vertex_dofs);
+		      node->set_n_comp_group(sys_num, vg,
+					     vertex_dofs);
+		      
 		      // Abusing dof_number to set a "this is a
 		      // vertex" flag
-		      node->set_dof_number(this->sys_number(),
-					   var, 0, vertex_dofs);
+		      node->set_vg_dof_base(sys_num, vg,
+					    vertex_dofs);
+		      
+		      // std::cout << "sys_num,vg,old_node_dofs,vertex_dofs="
+		      // 		<< sys_num << ","
+		      // 		<< vg << ","
+		      // 		<< old_node_dofs << ","
+		      // 		<< vertex_dofs << '\n',
+		      // 	node->debug_buffer();
+
+		      // libmesh_assert_equal_to (vertex_dofs, node->n_comp(sys_num, vg));
+		      // libmesh_assert_equal_to (vertex_dofs, node->vg_dof_base(sys_num, vg));
 		    }
 	        }
 	    }
@@ -641,8 +645,8 @@
 	  libmesh_assert(elem);
 
 	  // Skip the numbering if this variable is
-	  // not active on this element's subdoman
-	  if (!var_description.active_on_subdomain(elem->subdomain_id()))
+	  // not active on this element's subdomain
+	  if (!vg_description.active_on_subdomain(elem->subdomain_id()))
 	    continue;
 
 	  const ElemType type = elem->type();
@@ -658,10 +662,10 @@
 	      Node* node = elem->get_node(n);
 
 	      const unsigned int old_node_dofs =
-	        node->n_comp(this->sys_number(), var);
+	        node->n_comp_group(sys_num, vg);
 
               const unsigned int vertex_dofs = old_node_dofs?
-                node->dof_number (this->sys_number(),var,0):0;
+                node->vg_dof_base (sys_num,vg):0;
 
 	      const unsigned int new_node_dofs =
 		FEInterface::n_dofs_at_node(dim, fe_type, type, n);
@@ -670,7 +674,16 @@
 	      if (elem->is_vertex(n))
 	        {
 		  libmesh_assert_greater_equal (old_node_dofs, vertex_dofs);
-		  libmesh_assert_greater_equal (vertex_dofs, new_node_dofs);
+		  // //if (vertex_dofs < new_node_dofs)
+		  //   std::cout << "sys_num,vg,old_node_dofs,vertex_dofs,new_node_dofs="
+		  // 	      << sys_num << ","
+		  // 	      << vg << ","
+		  // 	      << old_node_dofs << ","
+		  // 	      << vertex_dofs << ","
+		  // 	      << new_node_dofs << '\n',
+		  //     node->debug_buffer();
+		  
+		  libmesh_assert_greater_equal (vertex_dofs,   new_node_dofs);
 		}
 	      // We need to allocate the rest
 	      else
@@ -679,13 +692,13 @@
 		  // dofs, so we just give it edge or face dofs
 		  if (!old_node_dofs)
                     {
-		      node->set_n_comp(this->sys_number(), var,
-				       new_node_dofs);
+		      node->set_n_comp_group(sys_num, vg,
+					     new_node_dofs);
 		      // Abusing dof_number to set a "this has no
 		      // vertex dofs" flag
                       if (new_node_dofs)
-		        node->set_dof_number(this->sys_number(),
-					     var, 0, 0);
+		        node->set_vg_dof_base(sys_num, vg,
+					      0);
                     }
 
 		  // If this has dofs, but has no vertex dofs,
@@ -695,10 +708,11 @@
 		    {
                       if (new_node_dofs > old_node_dofs)
                         {
-		          node->set_n_comp(this->sys_number(), var,
-				           new_node_dofs);
-		          node->set_dof_number(this->sys_number(),
-					       var, 0, vertex_dofs);
+		          node->set_n_comp_group(sys_num, vg,
+						 new_node_dofs);
+			  
+		          node->set_vg_dof_base(sys_num, vg,
+						vertex_dofs);
                         }
 		    }
 		  // If this is another element's vertex,
@@ -708,10 +722,11 @@
 		    {
                       if (new_node_dofs > old_node_dofs - vertex_dofs)
                         {
-		          node->set_n_comp(this->sys_number(), var,
-				           vertex_dofs + new_node_dofs);
-		          node->set_dof_number(this->sys_number(),
-					       var, 0, vertex_dofs);
+		          node->set_n_comp_group(sys_num, vg,
+						 vertex_dofs + new_node_dofs);
+			  
+		          node->set_vg_dof_base(sys_num, vg,
+						vertex_dofs);
                         }
 		    }
 		  // If this is another element's vertex, add any
@@ -721,10 +736,11 @@
 		      libmesh_assert_greater_equal (old_node_dofs, vertex_dofs);
                       if (new_node_dofs > old_node_dofs)
                         {
-		          node->set_n_comp(this->sys_number(), var,
-				           new_node_dofs);
-		          node->set_dof_number(this->sys_number(),
-					       var, 0, vertex_dofs);
+		          node->set_n_comp_group(sys_num, vg,
+						 new_node_dofs);
+			  
+		          node->set_vg_dof_base (sys_num, vg,
+						 vertex_dofs);
                         }
 		    }
 		}
@@ -734,32 +750,15 @@
 			  FEInterface::n_dofs_per_elem(dim, fe_type,
 						       type);
 
-	  elem->set_n_comp(this->sys_number(), var, dofs_per_elem);
+	  elem->set_n_comp_group(sys_num, vg, dofs_per_elem);
 
 	}
-    }
+    } // end loop over variable groups
 
   // Calling DofMap::reinit() by itself makes little sense,
   // so we won't bother with nonlocal DofObjects.
   // Those will be fixed by distribute_dofs
-/*
-  //------------------------------------------------------------
-  // At this point, all n_comp and dof_number values on local
-  // DofObjects should be correct, but a ParallelMesh might have
-  // incorrect values on non-local DofObjects.  Let's request the
-  // correct values from each other processor.
 
-  this->set_nonlocal_n_comps(mesh.nodes_begin(),
-                             mesh.nodes_end(),
-                             mesh,
-                             &DofMap::node_ptr);
-
-  this->set_nonlocal_n_comps(mesh.elements_begin(),
-                             mesh.elements_end(),
-                             mesh,
-                             &DofMap::elem_ptr);
-*/
-
   //------------------------------------------------------------
   // Finally, clear all the current DOF indices
   // (distribute_dofs expects them cleared!)
@@ -799,9 +798,9 @@
   //_dof_coupling->clear();
 
   _variables.clear();
+  _variable_groups.clear();
   _first_df.clear();
   _end_df.clear();
-  _var_first_local_df.clear();
   _send_list.clear();
   this->clear_sparsity();
   need_full_sparsity_pattern = false;
@@ -936,18 +935,9 @@
 void DofMap::distribute_local_dofs_node_major(unsigned int &next_free_dof,
                                               MeshBase& mesh)
 {
-  const unsigned int sys_num = this->sys_number();
-  const unsigned int n_vars  = this->n_variables();
+  const unsigned int sys_num       = this->sys_number();
+  const unsigned int n_var_groups  = this->n_variable_groups();
 
-  // We now only add remote dofs to the _send_list
-  // unsigned int send_list_size = 0;
-
-  // _var_first_local_df does not work with node_major dofs
-  _var_first_local_df.resize(n_vars+1);
-  std::fill (_var_first_local_df.begin(),
-	     _var_first_local_df.end(),
-	     DofObject::invalid_id);
-
   //-------------------------------------------------------------------------
   // First count and assign temporary numbers to local dofs
   MeshBase::element_iterator       elem_it  = mesh.active_local_elements_begin();
@@ -964,45 +954,51 @@
       for (unsigned int n=0; n<n_nodes; n++)
         {
           Node* node = elem->get_node(n);
-
-          for (unsigned var=0; var<n_vars; var++)
-          {
-	      if( (this->variable(var).type().family != SCALAR) &&
-                  (this->variable(var).active_on_subdomain(elem->subdomain_id())) )
-	      {
-		// assign dof numbers (all at once) if this is
-		// our node and if they aren't already there
-		if ((node->n_comp(sys_num,var) > 0) &&
-		    (node->processor_id() == libMesh::processor_id()) &&
-		    (node->dof_number(sys_num,var,0) ==
-		     DofObject::invalid_id))
-		  {
-		    node->set_dof_number(sys_num,
-					 var,
-					 0,
-					 next_free_dof);
-		    next_free_dof += node->n_comp(sys_num,var);
-		  }
-	      }
-          }
+	  
+          for (unsigned vg=0; vg<n_var_groups; vg++)
+	    {
+	      const VariableGroup &vg_description(this->variable_group(vg));
+	      
+	      if( (vg_description.type().family != SCALAR) &&
+                  (vg_description.active_on_subdomain(elem->subdomain_id())) )
+		{
+		  // assign dof numbers (all at once) if this is
+		  // our node and if they aren't already there
+		  if ((node->n_comp_group(sys_num,vg) > 0) &&
+		      (node->processor_id() == libMesh::processor_id()) &&
+		      (node->vg_dof_base(sys_num,vg) ==
+		       DofObject::invalid_id))
+		    {
+		      node->set_vg_dof_base(sys_num,
+					    vg,
+					    next_free_dof);
+		      next_free_dof += (vg_description.n_variables()*
+					node->n_comp_group(sys_num,vg));
+		    }
+		}
+	    }
         }
 
       // Now number the element DOFS
-      for (unsigned var=0; var<n_vars; var++)
-	if ( (this->variable(var).type().family != SCALAR) &&
-             (this->variable(var).active_on_subdomain(elem->subdomain_id())) )
-	  if (elem->n_comp(sys_num,var) > 0)
-	    {
-	      libmesh_assert_equal_to (elem->dof_number(sys_num,var,0),
-			               DofObject::invalid_id);
+      for (unsigned vg=0; vg<n_var_groups; vg++)
+	{
+	  const VariableGroup &vg_description(this->variable_group(vg));
 
-	      elem->set_dof_number(sys_num,
-				   var,
-				   0,
-				   next_free_dof);
+	  if ( (vg_description.type().family != SCALAR) &&
+	       (vg_description.active_on_subdomain(elem->subdomain_id())) )
+	    if (elem->n_comp_group(sys_num,vg) > 0)
+	      {
+		libmesh_assert_equal_to (elem->vg_dof_base(sys_num,vg),
+					 DofObject::invalid_id);
 
-	      next_free_dof += elem->n_comp(sys_num,var);
-	    }
+		elem->set_vg_dof_base(sys_num,
+				      vg,
+				      next_free_dof);
+
+		next_free_dof += (vg_description.n_variables()*
+				  elem->n_comp(sys_num,vg));		
+	      }
+	}
     } // done looping over elements
 
 
@@ -1023,27 +1019,34 @@
 	Node *node = *node_it;
 	libmesh_assert(node);
 
-	for (unsigned var=0; var<n_vars; var++)
-	  if (node->n_comp(sys_num,var))
-	    if (node->dof_number(sys_num,var,0) == DofObject::invalid_id)
-	      {
-		node->set_dof_number (sys_num,
-				      var,
-				      0,
-				      next_free_dof);
+	for (unsigned vg=0; vg<n_var_groups; vg++)
+	  {
+	    const VariableGroup &vg_description(this->variable_group(vg));
+	    
+	    if (node->n_comp_group(sys_num,vg))
+	      if (node->vg_dof_base(sys_num,vg) == DofObject::invalid_id)
+		{
+		  node->set_vg_dof_base (sys_num,
+					 vg,
+					 next_free_dof);
 
-		next_free_dof += node->n_comp(sys_num,var);
-	      }
+		  next_free_dof += (vg_description.n_variables()*
+				    node->n_comp(sys_num,vg));
+		}
+	  }
       }
   }
 
   // Finally, count up the SCALAR dofs
   this->_n_SCALAR_dofs = 0;
-  for (unsigned var=0; var<n_vars; var++)
+  for (unsigned vg=0; vg<n_var_groups; vg++)
     {
-      if( this->variable(var).type().family == SCALAR )
+      const VariableGroup &vg_description(this->variable_group(vg));
+      
+      if( vg_description.type().family == SCALAR )
         {
-          this->_n_SCALAR_dofs += this->variable(var).type().order;
+          this->_n_SCALAR_dofs += (vg_description.n_variables()*
+				   vg_description.type().order);
           continue;
         }
     }
@@ -1064,13 +1067,13 @@
       {
 	Node *obj = *node_it;
 	libmesh_assert(obj);
-	unsigned int n_variables = obj->n_vars(this->sys_number());
-	for (unsigned int v=0; v != n_variables; ++v)
+	unsigned int n_var_g = obj->n_var_groups(this->sys_number());
+	for (unsigned int vg=0; vg != n_var_g; ++vg)
 	  {
-	    unsigned int n_comp =
-	      obj->n_comp(this->sys_number(), v);
-	    unsigned int first_dof = n_comp ?
-	      obj->dof_number(this->sys_number(), v, 0) : 0;
+	    unsigned int n_comp_g =
+	      obj->n_comp_group(this->sys_number(), vg);
+	    unsigned int first_dof = n_comp_g ?
+	      obj->vg_dof_base(this->sys_number(), vg) : 0;
 	    libmesh_assert_not_equal_to (first_dof, DofObject::invalid_id);
 	  }
       }
@@ -1083,25 +1086,19 @@
 void DofMap::distribute_local_dofs_var_major(unsigned int &next_free_dof,
                                              MeshBase& mesh)
 {
-  const unsigned int sys_num = this->sys_number();
-  const unsigned int n_vars  = this->n_variables();
-
-  // We now only add remote dofs to the _send_list
-  // unsigned int send_list_size = 0;
-
-  // We will cache the first local index for each variable
-  _var_first_local_df.clear();
-
+  const unsigned int sys_num      = this->sys_number();
+  const unsigned int n_var_groups = this->n_variable_groups();
+  
   //-------------------------------------------------------------------------
   // First count and assign temporary numbers to local dofs
-  for (unsigned var=0; var<n_vars; var++)
+  for (unsigned vg=0; vg<n_var_groups; vg++)
     {
-      _var_first_local_df.push_back(next_free_dof);
+      const VariableGroup &vg_description(this->variable_group(vg));
 
-      const Variable var_description = this->variable(var);
-
+      const unsigned int n_vars_in_group = vg_description.n_variables();
+      
       // Skip the SCALAR dofs
-      if(var_description.type().family == SCALAR)
+      if (vg_description.type().family == SCALAR)
         continue;
 
       MeshBase::element_iterator       elem_it  = mesh.active_local_elements_begin();
@@ -1115,7 +1112,7 @@
 
 	  // ... and only variables which are active on
 	  // on this element's subdomain
-	  if (!var_description.active_on_subdomain(elem->subdomain_id()))
+	  if (!vg_description.active_on_subdomain(elem->subdomain_id()))
 	    continue;
 
           const unsigned int n_nodes = elem->n_nodes();
@@ -1127,31 +1124,32 @@
 
               // assign dof numbers (all at once) if this is
               // our node and if they aren't already there
-              if ((node->n_comp(sys_num,var) > 0) &&
+              if ((node->n_comp_group(sys_num,vg) > 0) &&
                   (node->processor_id() == libMesh::processor_id()) &&
-                  (node->dof_number(sys_num,var,0) ==
+                  (node->vg_dof_base(sys_num,vg) ==
                    DofObject::invalid_id))
                 {
-                  node->set_dof_number(sys_num,
-                                       var,
-                                       0,
-                                       next_free_dof);
-                  next_free_dof += node->n_comp(sys_num,var);
+                  node->set_vg_dof_base(sys_num,
+					vg,
+					next_free_dof);
+		  
+                  next_free_dof += (n_vars_in_group*
+				    node->n_comp_group(sys_num,vg));
                 }
             }
 
           // Now number the element DOFS
-          if (elem->n_comp(sys_num,var) > 0)
+          if (elem->n_comp_group(sys_num,vg) > 0)
             {
-              libmesh_assert_equal_to (elem->dof_number(sys_num,var,0),
+              libmesh_assert_equal_to (elem->vg_dof_base(sys_num,vg),
                                        DofObject::invalid_id);
 
-              elem->set_dof_number(sys_num,
-                                   var,
-                                   0,
-                                   next_free_dof);
+              elem->set_vg_dof_base(sys_num,
+				    vg,
+				    next_free_dof);
 
-              next_free_dof += elem->n_comp(sys_num,var);
+              next_free_dof += (n_vars_in_group*
+				elem->n_comp_group(sys_num,vg));
             }
         } // end loop on elements
 
@@ -1172,27 +1170,30 @@
 	    Node *node = *node_it;
 	    libmesh_assert(node);
 
-	    if (node->n_comp(sys_num,var))
-	      if (node->dof_number(sys_num,var,0) == DofObject::invalid_id)
+	    if (node->n_comp_group(sys_num,vg))
+	      if (node->vg_dof_base(sys_num,vg) == DofObject::invalid_id)
 		{
-		  node->set_dof_number (sys_num,
-					var,
-					0,
-					next_free_dof);
+		  node->set_vg_dof_base (sys_num,
+					 vg,
+					 next_free_dof);
 
-		  next_free_dof += node->n_comp(sys_num,var);
+		  next_free_dof += (n_vars_in_group*
+				    node->n_comp_group(sys_num,vg));
 		}
 	  }
       }
-    } // end loop on variables
+    } // end loop on variable groups
 
   // Finally, count up the SCALAR dofs
   this->_n_SCALAR_dofs = 0;
-  for (unsigned var=0; var<n_vars; var++)
+  for (unsigned vg=0; vg<n_var_groups; vg++)
     {
-      if( this->variable(var).type().family == SCALAR )
+      const VariableGroup &vg_description(this->variable_group(vg));
+      
+      if( vg_description.type().family == SCALAR )
         {
-          this->_n_SCALAR_dofs += this->variable(var).type().order;
+          this->_n_SCALAR_dofs += (vg_description.n_variables()*
+				   vg_description.type().order);
           continue;
         }
     }
@@ -1202,27 +1203,24 @@
   if ( libMesh::processor_id() == (libMesh::n_processors()-1) )
     next_free_dof += _n_SCALAR_dofs;
 
-  // Cache the last local dof number too
-  _var_first_local_df.push_back(next_free_dof);
-
 #ifdef DEBUG
   {
     // Make sure we didn't miss any nodes
     MeshTools::libmesh_assert_valid_procids<Node>(mesh);
-
+    
     MeshBase::node_iterator       node_it  = mesh.local_nodes_begin();
     const MeshBase::node_iterator node_end = mesh.local_nodes_end();
     for (; node_it != node_end; ++node_it)
       {
 	Node *obj = *node_it;
 	libmesh_assert(obj);
-	unsigned int n_variables = obj->n_vars(this->sys_number());
-	for (unsigned int v=0; v != n_variables; ++v)
+	unsigned int n_var_g = obj->n_var_groups(this->sys_number());
+	for (unsigned int vg=0; vg != n_var_g; ++vg)
 	  {
-	    unsigned int n_comp =
-	      obj->n_comp(this->sys_number(), v);
-	    unsigned int first_dof = n_comp ?
-	      obj->dof_number(this->sys_number(), v, 0) : 0;
+	    unsigned int n_comp_g =
+	      obj->n_comp_group(this->sys_number(), vg);
+	    unsigned int first_dof = n_comp_g ?
+	      obj->vg_dof_base(this->sys_number(), vg) : 0;
 	    libmesh_assert_not_equal_to (first_dof, DofObject::invalid_id);
 	  }
       }
@@ -1717,6 +1715,8 @@
   STOP_LOG("dof_indices()", "DofMap");
 }
 
+
+
 void DofMap::SCALAR_dof_indices (std::vector<unsigned int>& di,
 			         const unsigned int vn,
 #ifdef LIBMESH_ENABLE_AMR
Index: src/base/dof_object.C
===================================================================
--- src/base/dof_object.C	(revision 6518)
+++ src/base/dof_object.C	(working copy)
@@ -55,8 +55,12 @@
 
   for (unsigned int s=0; s<this->n_systems(); s++)
     {
-      libmesh_assert_equal_to (this->n_vars(s), dof_obj.n_vars(s));
+      libmesh_assert_equal_to (this->n_vars(s),       dof_obj.n_vars(s));
+      libmesh_assert_equal_to (this->n_var_groups(s), dof_obj.n_var_groups(s));
 
+      for (unsigned int vg=0; vg<this->n_var_groups(s); vg++)
+	libmesh_assert_equal_to (this->n_vars(s,vg), dof_obj.n_vars(s,vg));
+      
       for (unsigned int v=0; v<this->n_vars(s); v++)
 	{
 	  libmesh_assert_equal_to (this->n_comp(s,v), dof_obj.n_comp(s,v));
@@ -91,8 +95,12 @@
 
   for (unsigned int s=0; s<this->n_systems(); s++)
     {
-      libmesh_assert_equal_to (this->n_vars(s), dof_obj.n_vars(s));
+      libmesh_assert_equal_to (this->n_vars(s),       dof_obj.n_vars(s));
+      libmesh_assert_equal_to (this->n_var_groups(s), dof_obj.n_var_groups(s));
 
+      for (unsigned int vg=0; vg<this->n_var_groups(s); vg++)
+	libmesh_assert_equal_to (this->n_vars(s,vg), dof_obj.n_vars(s,vg));
+      
       for (unsigned int v=0; v<this->n_vars(s); v++)
 	{
 	  libmesh_assert_equal_to (this->n_comp(s,v), dof_obj.n_comp(s,v));
@@ -161,8 +169,11 @@
   // check that all systems now exist and that they have 0 size
   libmesh_assert_equal_to (ns, this->n_systems());
   for (unsigned int s=0; s<this->n_systems(); s++)
-    libmesh_assert_equal_to (this->n_vars(s), 0);
-
+    {
+      libmesh_assert_equal_to (this->n_vars(s),       0);
+      libmesh_assert_equal_to (this->n_var_groups(s), 0);
+    }
+  
 #endif
 }
 
@@ -195,15 +206,20 @@
 
   libmesh_assert_equal_to (this->n_systems(), (ns_orig+1));
   libmesh_assert_equal_to (this->n_vars(ns_orig), 0);
+  libmesh_assert_equal_to (this->n_var_groups(ns_orig), 0);
 }
 
 
 
-void DofObject::set_n_vars(const unsigned int s,
-			   const unsigned int nvars)
+void DofObject::set_n_vars_per_group(const unsigned int s,
+				     const std::vector<unsigned int> &nvpg)
 {
+  
   libmesh_assert_less (s, this->n_systems());
 
+  // number of varaible groups for this system - inferred
+  const unsigned int nvg = nvpg.size();
+  
   // BSK - note that for compatibility with the previous implementation
   // calling this method when (nvars == this->n_vars()) requires that
   // we invalidate the DOF indices and set the number of components to 0.
@@ -212,10 +228,13 @@
   // even in the case of (nvars == this->n_vars()), resulting in n_comp(s,v)
   // implicitly becoming 0 regardless of any previous value.
   // quick return?
-  if (nvars == this->n_vars(s))
+  if (nvg == this->n_var_groups(s))
     {
-      for (unsigned int v=0; v<nvars; v++)
-	this->set_n_comp(s,v,0);
+      for (unsigned int vg=0; vg<nvg; vg++)
+	{
+	  this->set_n_comp_group(s,vg,0);
+	  libmesh_assert_equal_to (this->n_vars(s,vg), nvpg[vg]);
+	}
       return;
     }
 
@@ -226,13 +245,13 @@
   old_system_sizes.reserve(this->n_systems());
 
   for (unsigned int s_ctr=0; s_ctr<this->n_systems(); s_ctr++)
-    old_system_sizes.push_back(this->n_vars(s_ctr));
+    old_system_sizes.push_back(this->n_var_groups(s_ctr));
 #endif
 
   // remove current indices if we have some
-  if (this->n_vars(s) != 0)
+  if (this->n_var_groups(s) != 0)
     {
-      const unsigned int old_nvars_s = this->n_vars(s);
+      const unsigned int old_nvg_s = this->n_var_groups(s);
 
       DofObject::index_buffer_t::iterator
 	it  = _idx_buf.begin(),
@@ -243,30 +262,30 @@
       _idx_buf.erase(it,end);
 
       for (unsigned int ctr=(s+1); ctr<this->n_systems(); ctr++)
-	_idx_buf[ctr] -= 2*old_nvars_s;
+	_idx_buf[ctr] -= 2*old_nvg_s;
     }
 
   // better not have any now!
-  libmesh_assert_equal_to (this->n_vars(s), 0);
+  libmesh_assert_equal_to (this->n_var_groups(s), 0);
 
   // had better not screwed up any of our sizes!
 #ifdef DEBUG
   for (unsigned int s_ctr=0; s_ctr<this->n_systems(); s_ctr++)
     if (s_ctr != s)
-      libmesh_assert_equal_to (this->n_vars(s_ctr), old_system_sizes[s_ctr]);
+      libmesh_assert_equal_to (this->n_var_groups(s_ctr), old_system_sizes[s_ctr]);
 #endif
 
   // OK, if the user requested 0 that is what we have
-  if (nvars == 0)
+  if (nvg == 0)
     return;
 
   {
     // array to hold new indices
-    DofObject::index_buffer_t var_idxs(2*nvars);
-    for (unsigned int v=0; v<nvars; v++)
-      {
-	var_idxs[2*v    ] = 0;
-	var_idxs[2*v + 1] = invalid_id - 1;
+    DofObject::index_buffer_t var_idxs(2*nvg);
+    for (unsigned int vg=0; vg<nvg; vg++)
+      {	
+	var_idxs[2*vg    ] = ncv_magic*nvpg[vg] + 0;
+	var_idxs[2*vg + 1] = invalid_id - 1;
       }
 
     DofObject::index_buffer_t::iterator it = _idx_buf.begin();
@@ -274,28 +293,38 @@
     _idx_buf.insert(it, var_idxs.begin(), var_idxs.end());
 
     for (unsigned int ctr=(s+1); ctr<this->n_systems(); ctr++)
-      _idx_buf[ctr] += 2*nvars;
+      _idx_buf[ctr] += 2*nvg;
 
     // resize _idx_buf to fit so no memory is wasted.
     DofObject::index_buffer_t(_idx_buf).swap(_idx_buf);
   }
 
   // that better had worked.  Assert stuff.
-  libmesh_assert_equal_to (nvars, this->n_vars(s));
+  libmesh_assert_equal_to (nvg, this->n_var_groups(s));
+  
+#ifdef DEBUG
 
-#ifdef DEBUG
+  // std::cout << " [ ";
+  // for (unsigned int i=0; i<_idx_buf.size(); i++)
+  //   std::cout << _idx_buf[i] << " ";
+  // std::cout << "]\n";
+
+  libmesh_assert_equal_to (this->n_var_groups(s), nvpg.size());
+
+  for (unsigned int vg=0; vg<this->n_var_groups(s); vg++)
+    {
+      libmesh_assert_equal_to (this->n_vars(s,vg), nvpg[vg]);
+      libmesh_assert_equal_to (this->n_comp_group(s,vg), 0);
+    }
+
   for (unsigned int v=0; v<this->n_vars(s); v++)
     libmesh_assert_equal_to (this->n_comp(s,v), 0);
+  
   // again, all other system sizes shoudl be unchanged!
   for (unsigned int s_ctr=0; s_ctr<this->n_systems(); s_ctr++)
     if (s_ctr != s)
-      libmesh_assert_equal_to (this->n_vars(s_ctr), old_system_sizes[s_ctr]);
+      libmesh_assert_equal_to (this->n_var_groups(s_ctr), old_system_sizes[s_ctr]);
 
-//   std::cout << " [ ";
-//   for (unsigned int i=0; i<_idx_buf.size(); i++)
-//     std::cout << _idx_buf[i] << " ";
-//   std::cout << "]\n";
-
 #endif
 }
 
@@ -305,26 +334,57 @@
 			   const unsigned int var,
 			   const unsigned int ncomp)
 {
-  libmesh_assert_less (s, this->n_systems());
+  libmesh_assert_less (s,   this->n_systems());
   libmesh_assert_less (var, this->n_vars(s));
 
+  this->set_n_comp_group(s, this->var_to_vg(s,var), ncomp);
+}
+
+
+
+void DofObject::set_n_comp_group(const unsigned int s,
+				 const unsigned int vg,
+				 const unsigned int ncomp)
+{
+  libmesh_assert_less (s,  this->n_systems());
+  libmesh_assert_less (vg, this->n_var_groups(s));
+  
   // Check for trivial return
-  if (ncomp == this->n_comp(s,var)) return;
+  if (ncomp == this->n_comp_group(s,vg)) return;
 
+#ifndef NDEBUG
+  if (ncomp >= ncv_magic)
+    {
+      const index_t ncvm = ncv_magic;
+      libMesh::err << "ERROR: ncomp must be less than DofObject::ncv_magic!\n"
+		   << "ncomp = " << ncomp << ", ncv_magic = " << ncvm
+		   << "\nrecompile and try again!\n";
+      libmesh_error();
+    }
+#endif
+  
   const unsigned int
     start_idx_sys = this->start_idx(s),
-    base_offset  = start_idx_sys + 2*var;
+    n_vars_group  = this->n_vars(s,vg),
+    base_offset   = start_idx_sys + 2*vg;
 
   libmesh_assert_less ((base_offset + 1), _idx_buf.size());
 
-  // set the number of components
-  _idx_buf[base_offset] = ncomp;
+  // if (ncomp)
+  //   std::cout << "s,vg,ncomp=" 
+  // 	      << s  << ","
+  // 	      << vg << ","
+  // 	      << ncomp << '\n';
 
+  // set the number of components, maintaining the number
+  // of variables in the group
+  _idx_buf[base_offset] = ncv_magic*n_vars_group + ncomp;
+
   // We use (invalid_id - 1) to signify no
   // components for this object
   _idx_buf[base_offset + 1] = (ncomp == 0) ? invalid_id - 1 : invalid_id;
 
-  libmesh_assert_equal_to (ncomp, this->n_comp(s,var));
+  libmesh_assert_equal_to (ncomp, this->n_comp(s,vg));
 }
 
 
@@ -334,22 +394,27 @@
 			       const unsigned int comp,
 			       const unsigned int dn)
 {
-  libmesh_assert_less (s, this->n_systems());
-  libmesh_assert_less (var, this->n_vars(s));
+  libmesh_assert_less (s,    this->n_systems());
+  libmesh_assert_less (var,  this->n_vars(s));
   libmesh_assert_less (comp, this->n_comp(s,var));
 
   const unsigned int
+    vg            = this->var_to_vg(s,var),
+    ncg           = this->n_comp_group(s,vg),
+    vig           = this->system_var_to_vg_var(s,vg,var),
     start_idx_sys = this->start_idx(s);
 
-  libmesh_assert_less ((start_idx_sys + 2*var + 1), _idx_buf.size());
+  libmesh_assert_less ((start_idx_sys + 2*vg + 1), _idx_buf.size());
 
   unsigned int
-    &base_idx(_idx_buf[start_idx_sys + 2*var + 1]);
+    &base_idx(_idx_buf[start_idx_sys + 2*vg + 1]);
 
-  //We intend to change all dof numbers together or not at all
-  if (comp)
+  // We intend to change all dof numbers together or not at all
+  if (comp || vig)
     libmesh_assert ((dn == invalid_id && base_idx == invalid_id) ||
-		    (dn == base_idx + comp));
+		    (dn == base_idx + vig*ncg + comp));
+  
+  // only explicitly store the base index for vig==0, comp==0
   else
     base_idx = dn;
 
@@ -358,12 +423,12 @@
 //   for (unsigned int i=0; i<_idx_buf.size(); i++)
 //     std::cout << _idx_buf[i] << " ";
 //   std::cout << "]\n";
-
 // #endif
 
   libmesh_assert_equal_to (this->dof_number(s, var, comp), dn);
 }
 
+  
 
 unsigned int DofObject::packed_indexing_size() const
 {
@@ -377,6 +442,7 @@
 }
 
 
+  
 unsigned int DofObject::unpackable_indexing_size(std::vector<int>::const_iterator begin)
 {
 #ifdef LIBMESH_ENABLE_AMR
@@ -454,4 +520,14 @@
 
 
 
+void DofObject::debug_buffer () const
+{
+  std::cout << " [ ";
+  for (unsigned int i=0; i<_idx_buf.size(); i++)
+    std::cout << _idx_buf[i] << " ";
+  std::cout << "]\n";
+}
+
+
+
 } // namespace libMesh
Index: src/systems/system.C
===================================================================
--- src/systems/system.C	(revision 6518)
+++ src/systems/system.C	(working copy)
@@ -1073,53 +1073,86 @@
 			           const FEType& type,
 				   const std::set<subdomain_id_type> * const active_subdomains)
 {
+  return this->add_variables (std::vector<std::string>(1, var),
+			      type,
+			      active_subdomains);
+}
+
+
+
+unsigned int System::add_variable (const std::string& var,
+			           const Order order,
+			           const FEFamily family,
+				   const std::set<subdomain_id_type> * const active_subdomains)
+{
+  return this->add_variables(std::vector<std::string>(1, var),
+			     FEType(order, family),
+			     active_subdomains);
+}
+
+
+
+unsigned int System::add_variables (const std::vector<std::string> &vars,
+				    const FEType& type,
+				    const std::set<subdomain_id_type> * const active_subdomains)
+{
+  const std::string var = vars[0];
+  
   // Make sure the variable isn't there already
   // or if it is, that it's the type we want
-  for (unsigned int v=0; v<this->n_vars(); v++)
-    if (this->variable_name(v) == var)
-      {
-	if (this->variable_type(v) == type)
-	  return _variables[v].number();
+  for (unsigned int ov=0; ov<vars.size(); ov++)
+    for (unsigned int v=0; v<this->n_vars(); v++)
+      if (this->variable_name(v) == vars[ov])
+	{
+	  if (this->variable_type(v) == type)
+	    return _variables[v].number();
+	  
+	  libMesh::err << "ERROR: incompatible variable "
+		       << vars[ov]
+		       << " has already been added for this system!"
+		       << std::endl;
+	  libmesh_error();
+	}
 
-	libMesh::err << "ERROR: incompatible variable "
-		      << var
-		      << " has already been added for this system!"
-		      << std::endl;
-	libmesh_error();
-      }
-
   const unsigned int curr_n_vars = this->n_vars();
 
   const unsigned int next_first_component = this->n_components();
 
-  // Add the variable to the list
-  _variables.push_back((active_subdomains == NULL) ?
-		       Variable(var, curr_n_vars,
-				next_first_component, type) :
-		       Variable(var, curr_n_vars,
-				next_first_component, type, *active_subdomains));
+  // Add the variable group to the list
+  _variable_groups.push_back((active_subdomains == NULL) ?
+			     VariableGroup(vars, curr_n_vars,
+					   next_first_component, type) :
+			     VariableGroup(vars, curr_n_vars,
+					   next_first_component, type, *active_subdomains));
 
-  libmesh_assert_equal_to ((curr_n_vars+1), this->n_vars());
+  const VariableGroup &vg (_variable_groups.back());
+  
+  // Add each component of the group individually
+  for (unsigned int v=0; v<vars.size(); v++)
+    {
+      _variables.push_back (vg(v));
+      _variable_numbers[vars[v]] = curr_n_vars+v;  
+    }
+  
+  libmesh_assert_equal_to ((curr_n_vars+vars.size()), this->n_vars());
+    
+  // Add the variable group to the _dof_map
+  _dof_map->add_variable_group (vg);
 
-  _variable_numbers[var] = curr_n_vars;
-
-  // Add the variable to the _dof_map
-  _dof_map->add_variable (_variables.back());
-
   // Return the number of the new variable
   return curr_n_vars;
 }
 
 
 
-unsigned int System::add_variable (const std::string& var,
-			           const Order order,
-			           const FEFamily family,
-				   const std::set<subdomain_id_type> * const active_subdomains)
+unsigned int System::add_variables (const std::vector<std::string> &vars,
+				    const Order order,
+				    const FEFamily family,
+				    const std::set<subdomain_id_type> * const active_subdomains)
 {
-  return this->add_variable(var,
-			    FEType(order, family),
-			    active_subdomains);
+  return this->add_variables(vars,
+			     FEType(order, family),
+			     active_subdomains);
 }
 
 
@@ -1535,9 +1568,16 @@
       << "    Type \""  << this->system_type() << "\"\n"
       << "    Variables=";
 
-  for (unsigned int vn=0; vn<this->n_vars(); vn++)
-      out << "\"" << this->variable_name(vn) << "\" ";
+  for (unsigned int vg=0; vg<this->n_variable_groups(); vg++)
+    {
+      const VariableGroup &vg_description (this->variable_group(vg));
 
+      if (vg_description.n_variables() > 1) out << "{ ";
+      for (unsigned int vn=0; vn<vg_description.n_variables(); vn++)
+	out << "\"" << vg_description.name(vn) << "\" ";
+      if (vg_description.n_variables() > 1) out << "}";      
+    }
+
   out << '\n';
 
   out << "    Finite Element Types=";
