<?php $root=""; ?>
<?php require($root."navigation.php"); ?>
<html>
<head>
  <?php load_style($root); ?>
</head>
 
<body>
 
<?php make_navigation("miscellaneous_ex6",$root)?>
 
<div class="content">
<a name="comments"></a> 
<br><br><br> <h1> The source file miscellaneous_ex6.C with comments: </h1> 
<div class = "comment">
<h1>Miscellaneous Example 6 - Meshing with LibMesh's TetGen and Triangle Interfaces</h1>

<br><br>LibMesh provides interfaces to both Triangle and TetGen for generating 
Delaunay triangulations and tetrahedralizations in two and three dimensions
(respectively).


<br><br>Local header files
</div>

<div class ="fragment">
<pre>
        #include "libmesh/elem.h"
        #include "libmesh/face_tri3.h"
        #include "libmesh/mesh.h"
        #include "libmesh/mesh_generation.h"
        #include "libmesh/mesh_tetgen_interface.h"
        #include "libmesh/mesh_triangle_holes.h"
        #include "libmesh/mesh_triangle_interface.h"
        #include "libmesh/node.h"
        #include "libmesh/serial_mesh.h"
        
</pre>
</div>
<div class = "comment">
Bring in everything from the libMesh namespace
</div>

<div class ="fragment">
<pre>
        using namespace libMesh;
        
</pre>
</div>
<div class = "comment">
Major functions called by main
</div>

<div class ="fragment">
<pre>
        void triangulate_domain();
        void tetrahedralize_domain();
        
</pre>
</div>
<div class = "comment">
Helper routine for tetrahedralize_domain().  Adds the points and elements
of a convex hull generated by TetGen to the input mesh
</div>

<div class ="fragment">
<pre>
        void add_cube_convex_hull_to_mesh(MeshBase& mesh, Point lower_limit, Point upper_limit);
        
        
        
        
</pre>
</div>
<div class = "comment">
Begin the main program.
</div>

<div class ="fragment">
<pre>
        int main (int argc, char** argv)
        {
</pre>
</div>
<div class = "comment">
Initialize libMesh and any dependent libaries, like in example 2.
</div>

<div class ="fragment">
<pre>
          LibMeshInit init (argc, argv);
        
          libmesh_example_assert(2 &lt;= LIBMESH_DIM, "2D support");
        
          std::cout &lt;&lt; "Triangulating an L-shaped domain with holes" &lt;&lt; std::endl;
        
</pre>
</div>
<div class = "comment">
1.) 2D triangulation of L-shaped domain with three holes of different shape
</div>

<div class ="fragment">
<pre>
          triangulate_domain();
          
          libmesh_example_assert(3 &lt;= LIBMESH_DIM, "3D support");
        
          std::cout &lt;&lt; "Tetrahedralizing a prismatic domain with a hole" &lt;&lt; std::endl;
        
</pre>
</div>
<div class = "comment">
2.) 3D tetrahedralization of rectangular domain with hole.
</div>

<div class ="fragment">
<pre>
          tetrahedralize_domain();
          
          return 0;
        }
        
        
        
        
        void triangulate_domain()
        {
        #ifdef LIBMESH_HAVE_TRIANGLE
</pre>
</div>
<div class = "comment">
Use typedefs for slightly less typing.
</div>

<div class ="fragment">
<pre>
          typedef TriangleInterface::Hole Hole;
          typedef TriangleInterface::PolygonHole PolygonHole;
          typedef TriangleInterface::ArbitraryHole ArbitraryHole;
        
</pre>
</div>
<div class = "comment">
Libmesh mesh that will eventually be created.
</div>

<div class ="fragment">
<pre>
          Mesh mesh(2);
            
</pre>
</div>
<div class = "comment">
The points which make up the L-shape:
</div>

<div class ="fragment">
<pre>
          mesh.add_point(Point( 0. ,  0.));
          mesh.add_point(Point( 0. , -1.));
          mesh.add_point(Point(-1. , -1.));
          mesh.add_point(Point(-1. ,  1.));
          mesh.add_point(Point( 1. ,  1.));
          mesh.add_point(Point( 1. ,  0.));
        
</pre>
</div>
<div class = "comment">
Declare the TriangleInterface object.  This is where
we can set parameters of the triangulation and where the
actual triangulate function lives.
</div>

<div class ="fragment">
<pre>
          TriangleInterface t(mesh);
        
</pre>
</div>
<div class = "comment">
Customize the variables for the triangulation
</div>

<div class ="fragment">
<pre>
          t.desired_area()       = .01;
        
</pre>
</div>
<div class = "comment">
A Planar Straight Line Graph (PSLG) is essentially a list
of segments which have to exist in the final triangulation.
For an L-shaped domain, Triangle will compute the convex
hull of boundary points if we do not specify the PSLG.
The PSLG algorithm is also required for triangulating domains
containing holes
</div>

<div class ="fragment">
<pre>
          t.triangulation_type() = TriangleInterface::PSLG;
        
</pre>
</div>
<div class = "comment">
Turn on/off Laplacian mesh smoothing after generation.
By default this is on.
</div>

<div class ="fragment">
<pre>
          t.smooth_after_generating() = true;
        
</pre>
</div>
<div class = "comment">
Define holes...
    

<br><br>hole_1 is a circle (discretized by 50 points)
</div>

<div class ="fragment">
<pre>
          PolygonHole hole_1(Point(-0.5,  0.5), // center
        		     0.25,              // radius
        		     50);               // n. points
        
</pre>
</div>
<div class = "comment">
hole_2 is itself a triangle
</div>

<div class ="fragment">
<pre>
          PolygonHole hole_2(Point(0.5, 0.5),   // center
        		     0.1,               // radius
        		     3);                // n. points
        
</pre>
</div>
<div class = "comment">
hole_3 is an ellipse of 100 points which we define here
</div>

<div class ="fragment">
<pre>
          Point ellipse_center(-0.5,  -0.5);
          const unsigned int n_ellipse_points=100;
          std::vector&lt;Point&gt; ellipse_points(n_ellipse_points);
          const Real
            dtheta = 2*libMesh::pi / static_cast&lt;Real&gt;(n_ellipse_points),
            a = .1,
            b = .2;
        
          for (unsigned int i=0; i&lt;n_ellipse_points; ++i)
            ellipse_points[i]= Point(ellipse_center(0)+a*cos(i*dtheta),
        			     ellipse_center(1)+b*sin(i*dtheta));
            
          ArbitraryHole hole_3(ellipse_center, ellipse_points);
        	
</pre>
</div>
<div class = "comment">
Create the vector of Hole*'s ...
</div>

<div class ="fragment">
<pre>
          std::vector&lt;Hole*&gt; holes;
          holes.push_back(&hole_1);
          holes.push_back(&hole_2);
          holes.push_back(&hole_3);
        	
</pre>
</div>
<div class = "comment">
... and attach it to the triangulator object
</div>

<div class ="fragment">
<pre>
          t.attach_hole_list(&holes);
        
</pre>
</div>
<div class = "comment">
Triangulate!
</div>

<div class ="fragment">
<pre>
          t.triangulate();
        
</pre>
</div>
<div class = "comment">
Write the result to file
</div>

<div class ="fragment">
<pre>
          mesh.write("delaunay_l_shaped_hole.e");
        
        #endif // LIBMESH_HAVE_TRIANGLE
        }
        
        
        
        void tetrahedralize_domain()
        {
        #ifdef LIBMESH_HAVE_TETGEN
</pre>
</div>
<div class = "comment">
The algorithm is broken up into several steps: 
1.) A convex hull is constructed for a rectangular hole.
2.) A convex hull is constructed for the domain exterior.
3.) Neighbor information is updated so TetGen knows there is a convex hull
4.) A vector of hole points is created.
5.) The domain is tetrahedralized, the mesh is written out, etc.
  

<br><br>The mesh we will eventually generate
</div>

<div class ="fragment">
<pre>
          SerialMesh mesh(3);
        
</pre>
</div>
<div class = "comment">
Lower and Upper bounding box limits for a rectangular hole within the unit cube.
</div>

<div class ="fragment">
<pre>
          Point hole_lower_limit(0.2, 0.2, 0.4);
          Point hole_upper_limit(0.8, 0.8, 0.6);
        
</pre>
</div>
<div class = "comment">
1.) Construct a convex hull for the hole
</div>

<div class ="fragment">
<pre>
          add_cube_convex_hull_to_mesh(mesh, hole_lower_limit, hole_upper_limit);
          
</pre>
</div>
<div class = "comment">
2.) Generate elements comprising the outer boundary of the domain.
</div>

<div class ="fragment">
<pre>
          add_cube_convex_hull_to_mesh(mesh, Point(0.,0.,0.), Point(1., 1., 1.));
        
</pre>
</div>
<div class = "comment">
3.) Update neighbor information so that TetGen can verify there is a convex hull.
</div>

<div class ="fragment">
<pre>
          mesh.find_neighbors();
        
</pre>
</div>
<div class = "comment">
4.) Set up vector of hole points
</div>

<div class ="fragment">
<pre>
          std::vector&lt;Point&gt; hole(1);
          hole[0] = Point( 0.5*(hole_lower_limit + hole_upper_limit) );
        
</pre>
</div>
<div class = "comment">
5.) Set parameters and tetrahedralize the domain
  

<br><br>0 means "use TetGen default value"
</div>

<div class ="fragment">
<pre>
          Real quality_constraint = 2.0;
        
</pre>
</div>
<div class = "comment">
The volume constraint determines the max-allowed tetrahedral
volume in the Mesh.  TetGen will split cells which are larger than
this size
</div>

<div class ="fragment">
<pre>
          Real volume_constraint = 0.001;
          
</pre>
</div>
<div class = "comment">
Construct the Delaunay tetrahedralization
</div>

<div class ="fragment">
<pre>
          TetGenMeshInterface t(mesh);
          t.triangulate_conformingDelaunayMesh_carvehole(hole, 
        						 quality_constraint, 
        						 volume_constraint);
         
</pre>
</div>
<div class = "comment">
Find neighbors, etc in preparation for writing out the Mesh
</div>

<div class ="fragment">
<pre>
          mesh.prepare_for_use();
        
</pre>
</div>
<div class = "comment">
Finally, write out the result
</div>

<div class ="fragment">
<pre>
          mesh.write("hole_3D.e");
        #endif // LIBMESH_HAVE_TETGEN
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        void add_cube_convex_hull_to_mesh(MeshBase& mesh, Point lower_limit, Point upper_limit)
        {
        #ifdef LIBMESH_HAVE_TETGEN
          SerialMesh cube_mesh(3);
        
          unsigned n_elem = 1;
        
          MeshTools::Generation::build_cube(cube_mesh,
        				    n_elem,n_elem,n_elem, // n. elements in each direction
        				    lower_limit(0), upper_limit(0),
        				    lower_limit(1), upper_limit(1),
        				    lower_limit(2), upper_limit(2),
        				    HEX8);
          
</pre>
</div>
<div class = "comment">
The pointset_convexhull() algorithm will ignore the Hex8s
in the Mesh, and just construct the triangulation
of the convex hull.
</div>

<div class ="fragment">
<pre>
          TetGenMeshInterface t(cube_mesh);
          t.pointset_convexhull(); 
          
</pre>
</div>
<div class = "comment">
Now add all nodes from the boundary of the cube_mesh to the input mesh.


<br><br>Map from "node id in cube_mesh" -> "node id in mesh".  Initially inserted
with a dummy value, later to be assigned a value by the input mesh.
</div>

<div class ="fragment">
<pre>
          std::map&lt;unsigned,unsigned&gt; node_id_map;
          typedef std::map&lt;unsigned,unsigned&gt;::iterator iterator;
        
          {
            MeshBase::element_iterator it = cube_mesh.elements_begin();
            const MeshBase::element_iterator end = cube_mesh.elements_end();
            for ( ; it != end; ++it) 
              {
        	Elem* elem = *it;
        	  
        	for (unsigned s=0; s&lt;elem-&gt;n_sides(); ++s)
        	  if (elem-&gt;neighbor(s) == NULL)
        	    {
</pre>
</div>
<div class = "comment">
Add the node IDs of this side to the set
</div>

<div class ="fragment">
<pre>
                      AutoPtr&lt;Elem&gt; side = elem-&gt;side(s);
        		
        	      for (unsigned n=0; n&lt;side-&gt;n_nodes(); ++n)
        		node_id_map.insert( std::make_pair(side-&gt;node(n), /*dummy_value=*/0) );
        	    }
              }
          }
        
</pre>
</div>
<div class = "comment">
For each node in the map, insert it into the input mesh and keep 
track of the ID assigned.
</div>

<div class ="fragment">
<pre>
          for (iterator it=node_id_map.begin(); it != node_id_map.end(); ++it)
            {
</pre>
</div>
<div class = "comment">
Id of the node in the cube mesh
</div>

<div class ="fragment">
<pre>
              unsigned id = (*it).first;
        
</pre>
</div>
<div class = "comment">
Pointer to node in the cube mesh
</div>

<div class ="fragment">
<pre>
              Node* old_node = cube_mesh.node_ptr(id);
        
</pre>
</div>
<div class = "comment">
Add geometric point to input mesh
</div>

<div class ="fragment">
<pre>
              Node* new_node = mesh.add_point ( *old_node );
        
</pre>
</div>
<div class = "comment">
Track ID value of new_node in map
</div>

<div class ="fragment">
<pre>
              (*it).second = new_node-&gt;id();
            }
          
</pre>
</div>
<div class = "comment">
With the points added and the map data structure in place, we are
ready to add each TRI3 element of the cube_mesh to the input Mesh 
with proper node assignments
</div>

<div class ="fragment">
<pre>
          {
            MeshBase::element_iterator       el     = cube_mesh.elements_begin();
            const MeshBase::element_iterator end_el = cube_mesh.elements_end();
            
            for (; el != end_el; ++el)
              {
        	Elem* old_elem = *el;
        
        	if (old_elem-&gt;type() == TRI3)
        	  {
        	    Elem* new_elem = mesh.add_elem(new Tri3);
        
</pre>
</div>
<div class = "comment">
Assign nodes in new elements.  Since this is an example,
we'll do it in several steps.
</div>

<div class ="fragment">
<pre>
                    for (unsigned i=0; i&lt;old_elem-&gt;n_nodes(); ++i)
        	      {
</pre>
</div>
<div class = "comment">
Locate old node ID in the map
</div>

<div class ="fragment">
<pre>
                        iterator it = node_id_map.find(old_elem-&gt;node(i));
        
</pre>
</div>
<div class = "comment">
Check for not found
</div>

<div class ="fragment">
<pre>
                        if (it == node_id_map.end())
        		  {
        		    libMesh::err &lt;&lt; "Node id " &lt;&lt; old_elem-&gt;node(i) &lt;&lt; " not found in map!" &lt;&lt; std::endl;
        		    libmesh_error();
        		  }
        
</pre>
</div>
<div class = "comment">
Mapping to node ID in input mesh
</div>

<div class ="fragment">
<pre>
                        unsigned new_node_id = (*it).second;
        
</pre>
</div>
<div class = "comment">
Node pointer assigned from input mesh
</div>

<div class ="fragment">
<pre>
                        new_elem-&gt;set_node(i) = mesh.node_ptr(new_node_id);
        	      }
        	  }
              }
          }
        #endif // LIBMESH_HAVE_TETGEN
        }
</pre>
</div>

<a name="nocomments"></a> 
<br><br><br> <h1> The source file miscellaneous_ex6.C without comments: </h1> 
<pre> 
  
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/elem.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/face_tri3.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh_generation.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh_tetgen_interface.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh_triangle_holes.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh_triangle_interface.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/node.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/serial_mesh.h&quot;</FONT></B>
  
  using namespace libMesh;
  
  <B><FONT COLOR="#228B22">void</FONT></B> triangulate_domain();
  <B><FONT COLOR="#228B22">void</FONT></B> tetrahedralize_domain();
  
  <B><FONT COLOR="#228B22">void</FONT></B> add_cube_convex_hull_to_mesh(MeshBase&amp; mesh, Point lower_limit, Point upper_limit);
  
  
  
  
  <B><FONT COLOR="#228B22">int</FONT></B> main (<B><FONT COLOR="#228B22">int</FONT></B> argc, <B><FONT COLOR="#228B22">char</FONT></B>** argv)
  {
    LibMeshInit init (argc, argv);
  
    libmesh_example_assert(2 &lt;= LIBMESH_DIM, <B><FONT COLOR="#BC8F8F">&quot;2D support&quot;</FONT></B>);
  
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Triangulating an L-shaped domain with holes&quot;</FONT></B> &lt;&lt; std::endl;
  
    triangulate_domain();
    
    libmesh_example_assert(3 &lt;= LIBMESH_DIM, <B><FONT COLOR="#BC8F8F">&quot;3D support&quot;</FONT></B>);
  
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Tetrahedralizing a prismatic domain with a hole&quot;</FONT></B> &lt;&lt; std::endl;
  
    tetrahedralize_domain();
    
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
  
  
  
  
  <B><FONT COLOR="#228B22">void</FONT></B> triangulate_domain()
  {
  #ifdef LIBMESH_HAVE_TRIANGLE
    <B><FONT COLOR="#228B22">typedef</FONT></B> TriangleInterface::Hole Hole;
    <B><FONT COLOR="#228B22">typedef</FONT></B> TriangleInterface::PolygonHole PolygonHole;
    <B><FONT COLOR="#228B22">typedef</FONT></B> TriangleInterface::ArbitraryHole ArbitraryHole;
  
    Mesh mesh(2);
      
    mesh.add_point(Point( 0. ,  0.));
    mesh.add_point(Point( 0. , -1.));
    mesh.add_point(Point(-1. , -1.));
    mesh.add_point(Point(-1. ,  1.));
    mesh.add_point(Point( 1. ,  1.));
    mesh.add_point(Point( 1. ,  0.));
  
    TriangleInterface t(mesh);
  
    t.desired_area()       = .01;
  
    t.triangulation_type() = TriangleInterface::PSLG;
  
    t.smooth_after_generating() = true;
  
      
    PolygonHole hole_1(Point(-0.5,  0.5), <I><FONT COLOR="#B22222">// center
</FONT></I>  		     0.25,              <I><FONT COLOR="#B22222">// radius
</FONT></I>  		     50);               <I><FONT COLOR="#B22222">// n. points
</FONT></I>  
    PolygonHole hole_2(Point(0.5, 0.5),   <I><FONT COLOR="#B22222">// center
</FONT></I>  		     0.1,               <I><FONT COLOR="#B22222">// radius
</FONT></I>  		     3);                <I><FONT COLOR="#B22222">// n. points
</FONT></I>  
    Point ellipse_center(-0.5,  -0.5);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_ellipse_points=100;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;Point&gt; ellipse_points(n_ellipse_points);
    <B><FONT COLOR="#228B22">const</FONT></B> Real
      dtheta = 2*libMesh::pi / static_cast&lt;Real&gt;(n_ellipse_points),
      a = .1,
      b = .2;
  
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;n_ellipse_points; ++i)
      ellipse_points[i]= Point(ellipse_center(0)+a*cos(i*dtheta),
  			     ellipse_center(1)+b*sin(i*dtheta));
      
    ArbitraryHole hole_3(ellipse_center, ellipse_points);
  	
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;Hole*&gt; holes;
    holes.push_back(&amp;hole_1);
    holes.push_back(&amp;hole_2);
    holes.push_back(&amp;hole_3);
  	
    t.attach_hole_list(&amp;holes);
  
    t.triangulate();
  
    mesh.write(<B><FONT COLOR="#BC8F8F">&quot;delaunay_l_shaped_hole.e&quot;</FONT></B>);
  
  #endif <I><FONT COLOR="#B22222">// LIBMESH_HAVE_TRIANGLE
</FONT></I>  }
  
  
  
  <B><FONT COLOR="#228B22">void</FONT></B> tetrahedralize_domain()
  {
  #ifdef LIBMESH_HAVE_TETGEN
    
    SerialMesh mesh(3);
  
    Point hole_lower_limit(0.2, 0.2, 0.4);
    Point hole_upper_limit(0.8, 0.8, 0.6);
  
    add_cube_convex_hull_to_mesh(mesh, hole_lower_limit, hole_upper_limit);
    
    add_cube_convex_hull_to_mesh(mesh, Point(0.,0.,0.), Point(1., 1., 1.));
  
    mesh.find_neighbors();
  
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;Point&gt; hole(1);
    hole[0] = Point( 0.5*(hole_lower_limit + hole_upper_limit) );
  
    
    Real quality_constraint = 2.0;
  
    Real volume_constraint = 0.001;
    
    TetGenMeshInterface t(mesh);
    t.triangulate_conformingDelaunayMesh_carvehole(hole, 
  						 quality_constraint, 
  						 volume_constraint);
   
    mesh.prepare_for_use();
  
    mesh.write(<B><FONT COLOR="#BC8F8F">&quot;hole_3D.e&quot;</FONT></B>);
  #endif <I><FONT COLOR="#B22222">// LIBMESH_HAVE_TETGEN
</FONT></I>  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  <B><FONT COLOR="#228B22">void</FONT></B> add_cube_convex_hull_to_mesh(MeshBase&amp; mesh, Point lower_limit, Point upper_limit)
  {
  #ifdef LIBMESH_HAVE_TETGEN
    SerialMesh cube_mesh(3);
  
    <B><FONT COLOR="#228B22">unsigned</FONT></B> n_elem = 1;
  
    <B><FONT COLOR="#5F9EA0">MeshTools</FONT></B>::Generation::build_cube(cube_mesh,
  				    n_elem,n_elem,n_elem, <I><FONT COLOR="#B22222">// n. elements in each direction
</FONT></I>  				    lower_limit(0), upper_limit(0),
  				    lower_limit(1), upper_limit(1),
  				    lower_limit(2), upper_limit(2),
  				    HEX8);
    
    TetGenMeshInterface t(cube_mesh);
    t.pointset_convexhull(); 
    
  
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::map&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B>,<B><FONT COLOR="#228B22">unsigned</FONT></B>&gt; node_id_map;
    <B><FONT COLOR="#228B22">typedef</FONT></B> std::map&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B>,<B><FONT COLOR="#228B22">unsigned</FONT></B>&gt;::iterator iterator;
  
    {
      <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::element_iterator it = cube_mesh.elements_begin();
      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::element_iterator end = cube_mesh.elements_end();
      <B><FONT COLOR="#A020F0">for</FONT></B> ( ; it != end; ++it) 
        {
  	Elem* elem = *it;
  	  
  	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> s=0; s&lt;elem-&gt;n_sides(); ++s)
  	  <B><FONT COLOR="#A020F0">if</FONT></B> (elem-&gt;neighbor(s) == NULL)
  	    {
  	      AutoPtr&lt;Elem&gt; side = elem-&gt;side(s);
  		
  	      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> n=0; n&lt;side-&gt;n_nodes(); ++n)
  		node_id_map.insert( std::make_pair(side-&gt;node(n), <I><FONT COLOR="#B22222">/*dummy_value=*/</FONT></I>0) );
  	    }
        }
    }
  
    <B><FONT COLOR="#A020F0">for</FONT></B> (iterator it=node_id_map.begin(); it != node_id_map.end(); ++it)
      {
        <B><FONT COLOR="#228B22">unsigned</FONT></B> id = (*it).first;
  
        Node* old_node = cube_mesh.node_ptr(id);
  
        Node* new_node = mesh.add_point ( *old_node );
  
        (*it).second = new_node-&gt;id();
      }
    
    {
      <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::element_iterator       el     = cube_mesh.elements_begin();
      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::element_iterator end_el = cube_mesh.elements_end();
      
      <B><FONT COLOR="#A020F0">for</FONT></B> (; el != end_el; ++el)
        {
  	Elem* old_elem = *el;
  
  	<B><FONT COLOR="#A020F0">if</FONT></B> (old_elem-&gt;type() == TRI3)
  	  {
  	    Elem* new_elem = mesh.add_elem(<B><FONT COLOR="#A020F0">new</FONT></B> Tri3);
  
  	    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> i=0; i&lt;old_elem-&gt;n_nodes(); ++i)
  	      {
  		iterator it = node_id_map.find(old_elem-&gt;node(i));
  
  		<B><FONT COLOR="#A020F0">if</FONT></B> (it == node_id_map.end())
  		  {
  		    <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::err &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Node id &quot;</FONT></B> &lt;&lt; old_elem-&gt;node(i) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; not found in map!&quot;</FONT></B> &lt;&lt; std::endl;
  		    libmesh_error();
  		  }
  
  		<B><FONT COLOR="#228B22">unsigned</FONT></B> new_node_id = (*it).second;
  
  		new_elem-&gt;set_node(i) = mesh.node_ptr(new_node_id);
  	      }
  	  }
        }
    }
  #endif <I><FONT COLOR="#B22222">// LIBMESH_HAVE_TETGEN
</FONT></I>  }
</pre> 
<a name="output"></a> 
<br><br><br> <h1> The console output of the program: </h1> 
<pre>
***************************************************************
* Running Example miscellaneous_ex6:
*  mpirun -np 12 example-devel  -pc_type bjacobi -sub_pc_type ilu -sub_pc_factor_levels 4 -sub_pc_factor_zeropivot 0 -ksp_right_pc -log_summary
***************************************************************
 
Triangulating an L-shaped domain with holes
Tetrahedralizing a prismatic domain with a hole
************************************************************************************************************************
***             WIDEN YOUR WINDOW TO 120 CHARACTERS.  Use 'enscript -r -fCourier9' to print this document            ***
************************************************************************************************************************

---------------------------------------------- PETSc Performance Summary: ----------------------------------------------

/workspace/libmesh/examples/miscellaneous/miscellaneous_ex6/.libs/lt-example-devel on a intel-12. named hbar.ices.utexas.edu with 12 processors, by benkirk Thu Jan 31 22:10:22 2013
Using Petsc Release Version 3.3.0, Patch 2, Fri Jul 13 15:42:00 CDT 2012 

                         Max       Max/Min        Avg      Total 
Time (sec):           3.338e-01      1.00000   3.338e-01
Objects:              1.000e+00      1.00000   1.000e+00
Flops:                0.000e+00      0.00000   0.000e+00  0.000e+00
Flops/sec:            0.000e+00      0.00000   0.000e+00  0.000e+00
MPI Messages:         0.000e+00      0.00000   0.000e+00  0.000e+00
MPI Message Lengths:  0.000e+00      0.00000   0.000e+00  0.000e+00
MPI Reductions:       1.000e+00      1.00000

Flop counting convention: 1 flop = 1 real number operation of type (multiply/divide/add/subtract)
                            e.g., VecAXPY() for real vectors of length N --> 2N flops
                            and VecAXPY() for complex vectors of length N --> 8N flops

Summary of Stages:   ----- Time ------  ----- Flops -----  --- Messages ---  -- Message Lengths --  -- Reductions --
                        Avg     %Total     Avg     %Total   counts   %Total     Avg         %Total   counts   %Total 
 0:      Main Stage: 3.3373e-01 100.0%  0.0000e+00   0.0%  0.000e+00   0.0%  0.000e+00        0.0%  0.000e+00   0.0% 

------------------------------------------------------------------------------------------------------------------------
See the 'Profiling' chapter of the users' manual for details on interpreting output.
Phase summary info:
   Count: number of times phase was executed
   Time and Flops: Max - maximum over all processors
                   Ratio - ratio of maximum to minimum over all processors
   Mess: number of messages sent
   Avg. len: average message length
   Reduct: number of global reductions
   Global: entire computation
   Stage: stages of a computation. Set stages with PetscLogStagePush() and PetscLogStagePop().
      %T - percent time in this phase         %f - percent flops in this phase
      %M - percent messages in this phase     %L - percent message lengths in this phase
      %R - percent reductions in this phase
   Total Mflop/s: 10e-6 * (sum of flops over all processors)/(max time over all processors)
------------------------------------------------------------------------------------------------------------------------
Event                Count      Time (sec)     Flops                             --- Global ---  --- Stage ---   Total
                   Max Ratio  Max     Ratio   Max  Ratio  Mess   Avg len Reduct  %T %f %M %L %R  %T %f %M %L %R Mflop/s
------------------------------------------------------------------------------------------------------------------------

--- Event Stage 0: Main Stage

------------------------------------------------------------------------------------------------------------------------

Memory usage is given in bytes:

Object Type          Creations   Destructions     Memory  Descendants' Mem.
Reports information only for process 0.

--- Event Stage 0: Main Stage

              Viewer     1              0            0     0
========================================================================================================================
Average time to get PetscTime(): 0
Average time for MPI_Barrier(): 8.01086e-06
Average time for zero size MPI_Send(): 1.60933e-05
#PETSc Option Table entries:
-ksp_right_pc
-log_summary
-pc_type bjacobi
-sub_pc_factor_levels 4
-sub_pc_factor_zeropivot 0
-sub_pc_type ilu
#End of PETSc Option Table entries
Compiled without FORTRAN kernels
Compiled with full precision matrices (default)
sizeof(short) 2 sizeof(int) 4 sizeof(long) 8 sizeof(void*) 8 sizeof(PetscScalar) 8 sizeof(PetscInt) 4
Configure run at: Thu Nov  8 11:21:02 2012
Configure options: --with-debugging=false --COPTFLAGS=-O3 --CXXOPTFLAGS=-O3 --FOPTFLAGS=-O3 --with-clanguage=C++ --with-shared-libraries=1 --with-mpi-dir=/opt/apps/ossw/libraries/mpich2/mpich2-1.4.1p1/sl6/intel-12.1 --with-mumps=true --download-mumps=1 --with-metis=true --download-metis=1 --with-parmetis=true --download-parmetis=1 --with-superlu=true --download-superlu=1 --with-superludir=true --download-superlu_dist=1 --with-blacs=true --download-blacs=1 --with-scalapack=true --download-scalapack=1 --with-hypre=true --download-hypre=1 --with-blas-lib="[/opt/apps/sysnet/intel/12.1/mkl/10.3.12.361/lib/intel64/libmkl_intel_lp64.so,/opt/apps/sysnet/intel/12.1/mkl/10.3.12.361/lib/intel64/libmkl_sequential.so,/opt/apps/sysnet/intel/12.1/mkl/10.3.12.361/lib/intel64/libmkl_core.so]" --with-lapack-lib="[/opt/apps/sysnet/intel/12.1/mkl/10.3.12.361/lib/intel64/libmkl_lapack95_lp64.a]"
-----------------------------------------
Libraries compiled on Thu Nov  8 11:21:02 2012 on daedalus.ices.utexas.edu 
Machine characteristics: Linux-2.6.32-279.1.1.el6.x86_64-x86_64-with-redhat-6.3-Carbon
Using PETSc directory: /opt/apps/ossw/libraries/petsc/petsc-3.3-p2
Using PETSc arch: intel-12.1-mkl-intel-10.3.12.361-mpich2-1.4.1p1-cxx-opt
-----------------------------------------

Using C compiler: /opt/apps/ossw/libraries/mpich2/mpich2-1.4.1p1/sl6/intel-12.1/bin/mpicxx  -wd1572 -O3   -fPIC   ${COPTFLAGS} ${CFLAGS}
Using Fortran compiler: /opt/apps/ossw/libraries/mpich2/mpich2-1.4.1p1/sl6/intel-12.1/bin/mpif90  -fPIC -O3   ${FOPTFLAGS} ${FFLAGS} 
-----------------------------------------

Using include paths: -I/opt/apps/ossw/libraries/petsc/petsc-3.3-p2/intel-12.1-mkl-intel-10.3.12.361-mpich2-1.4.1p1-cxx-opt/include -I/opt/apps/ossw/libraries/petsc/petsc-3.3-p2/include -I/opt/apps/ossw/libraries/petsc/petsc-3.3-p2/include -I/opt/apps/ossw/libraries/petsc/petsc-3.3-p2/intel-12.1-mkl-intel-10.3.12.361-mpich2-1.4.1p1-cxx-opt/include -I/opt/apps/ossw/libraries/mpich2/mpich2-1.4.1p1/sl6/intel-12.1/include
-----------------------------------------

Using C linker: /opt/apps/ossw/libraries/mpich2/mpich2-1.4.1p1/sl6/intel-12.1/bin/mpicxx
Using Fortran linker: /opt/apps/ossw/libraries/mpich2/mpich2-1.4.1p1/sl6/intel-12.1/bin/mpif90
Using libraries: -Wl,-rpath,/opt/apps/ossw/libraries/petsc/petsc-3.3-p2/intel-12.1-mkl-intel-10.3.12.361-mpich2-1.4.1p1-cxx-opt/lib -L/opt/apps/ossw/libraries/petsc/petsc-3.3-p2/intel-12.1-mkl-intel-10.3.12.361-mpich2-1.4.1p1-cxx-opt/lib -lpetsc -lX11 -Wl,-rpath,/opt/apps/ossw/libraries/petsc/petsc-3.3-p2/intel-12.1-mkl-intel-10.3.12.361-mpich2-1.4.1p1-cxx-opt/lib -L/opt/apps/ossw/libraries/petsc/petsc-3.3-p2/intel-12.1-mkl-intel-10.3.12.361-mpich2-1.4.1p1-cxx-opt/lib -lcmumps -ldmumps -lsmumps -lzmumps -lmumps_common -lpord -lHYPRE -lpthread -lsuperlu_dist_3.0 -lparmetis -lmetis -lscalapack -lblacs -lsuperlu_4.3 -Wl,-rpath,/opt/apps/sysnet/intel/12.1/mkl/10.3.12.361/lib/intel64 -L/opt/apps/sysnet/intel/12.1/mkl/10.3.12.361/lib/intel64 -lmkl_lapack95_lp64 -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -Wl,-rpath,/opt/apps/ossw/libraries/mpich2/mpich2-1.4.1p1/sl6/intel-12.1/lib -L/opt/apps/ossw/libraries/mpich2/mpich2-1.4.1p1/sl6/intel-12.1/lib -Wl,-rpath,/opt/apps/sysnet/intel/12.1/composer_xe_2011_sp1.7.256/compiler/lib/intel64 -L/opt/apps/sysnet/intel/12.1/composer_xe_2011_sp1.7.256/compiler/lib/intel64 -Wl,-rpath,/usr/lib/gcc/x86_64-redhat-linux/4.4.6 -L/usr/lib/gcc/x86_64-redhat-linux/4.4.6 -lmpichf90 -lifport -lifcore -lm -lm -lmpichcxx -ldl -lmpich -lopa -lmpl -lrt -lpthread -limf -lsvml -lipgo -ldecimal -lcilkrts -lstdc++ -lgcc_s -lirc -lirc_s -ldl 
-----------------------------------------


 ----------------------------------------------------------------------------------------------------------------------
| Processor id:   0                                                                                                    |
| Num Processors: 12                                                                                                   |
| Time:           Thu Jan 31 22:10:22 2013                                                                             |
| OS:             Linux                                                                                                |
| HostName:       hbar.ices.utexas.edu                                                                                 |
| OS Release:     2.6.32-279.1.1.el6.x86_64                                                                            |
| OS Version:     #1 SMP Tue Jul 10 11:24:23 CDT 2012                                                                  |
| Machine:        x86_64                                                                                               |
| Username:       benkirk                                                                                              |
| Configuration:  ./configure  '--enable-everything'                                                                   |
|  '--prefix=/workspace/libmesh/install'                                                                               |
|  'CXX=icpc'                                                                                                          |
|  'CC=icc'                                                                                                            |
|  'FC=ifort'                                                                                                          |
|  'F77=ifort'                                                                                                         |
|  'PETSC_DIR=/opt/apps/ossw/libraries/petsc/petsc-3.3-p2'                                                             |
|  'PETSC_ARCH=intel-12.1-mkl-intel-10.3.12.361-mpich2-1.4.1p1-cxx-opt'                                                |
|  'SLEPC_DIR=/opt/apps/ossw/libraries/slepc/slepc-3.3-p2-petsc-3.3-p2-cxx-opt'                                        |
|  'TRILINOS_DIR=/opt/apps/ossw/libraries/trilinos/trilinos-10.12.2/sl6/intel-12.1/mpich2-1.4.1p1/mkl-intel-10.3.12.361'|
|  'VTK_DIR=/opt/apps/ossw/libraries/vtk/vtk-5.10.0/sl6/intel-12.1'                                                    |
 ----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------
| libMesh Performance: Alive time=0.384824, Active time=0.236021                                            |
 -----------------------------------------------------------------------------------------------------------
| Event                         nCalls    Total Time  Avg Time    Total Time  Avg Time    % of Active Time  |
|                                         w/o Sub     w/o Sub     With Sub    With Sub    w/o S    With S   |
|-----------------------------------------------------------------------------------------------------------|
|                                                                                                           |
|                                                                                                           |
| Mesh                                                                                                      |
|   find_neighbors()            5         0.0493      0.009866    0.0515      0.010304    20.90    21.83    |
|   renumber_nodes_and_elem()   6         0.0015      0.000256    0.0015      0.000256    0.65     0.65     |
|   write()                     2         0.0164      0.008207    0.0167      0.008356    6.95     7.08     |
|                                                                                                           |
| MeshCommunication                                                                                         |
|   compute_hilbert_indices()   2         0.0315      0.015730    0.0315      0.015730    13.33    13.33    |
|   find_global_indices()       2         0.0111      0.005563    0.0488      0.024403    4.71     20.68    |
|   parallel_sort()             2         0.0037      0.001871    0.0046      0.002289    1.59     1.94     |
|                                                                                                           |
| MeshTools::Generation                                                                                     |
|   build_cube()                2         0.0003      0.000128    0.0003      0.000128    0.11     0.11     |
|                                                                                                           |
| MetisPartitioner                                                                                          |
|   partition()                 1         0.1018      0.101809    0.1257      0.125685    43.14    53.25    |
|                                                                                                           |
| Parallel                                                                                                  |
|   allgather()                 6         0.0006      0.000105    0.0008      0.000127    0.27     0.32     |
|   broadcast()                 2         0.0000      0.000010    0.0000      0.000010    0.01     0.01     |
|   max(scalar)                 129       0.0013      0.000010    0.0013      0.000010    0.54     0.54     |
|   max(vector)                 31        0.0005      0.000017    0.0014      0.000046    0.22     0.60     |
|   min(bool)                   153       0.0014      0.000009    0.0014      0.000009    0.59     0.59     |
|   min(scalar)                 124       0.0059      0.000048    0.0059      0.000048    2.50     2.50     |
|   min(vector)                 31        0.0006      0.000020    0.0018      0.000058    0.26     0.76     |
|   probe()                     110       0.0008      0.000008    0.0008      0.000008    0.36     0.36     |
|   receive()                   110       0.0007      0.000007    0.0016      0.000015    0.31     0.68     |
|   send()                      110       0.0004      0.000003    0.0004      0.000003    0.16     0.16     |
|   send_receive()              114       0.0009      0.000008    0.0033      0.000029    0.37     1.39     |
|   sum()                       6         0.0004      0.000075    0.0008      0.000139    0.19     0.35     |
|                                                                                                           |
| Parallel::Request                                                                                         |
|   wait()                      110       0.0003      0.000003    0.0003      0.000003    0.14     0.14     |
|                                                                                                           |
| Partitioner                                                                                               |
|   set_node_processor_ids()    1         0.0028      0.002846    0.0047      0.004729    1.21     2.00     |
|   set_parent_processor_ids()  1         0.0035      0.003460    0.0035      0.003460    1.47     1.47     |
|   single_partition()          2         0.0001      0.000029    0.0001      0.000029    0.02     0.02     |
 -----------------------------------------------------------------------------------------------------------
| Totals:                       1062      0.2360                                          100.00            |
 -----------------------------------------------------------------------------------------------------------

 
***************************************************************
* Done Running Example miscellaneous_ex6:
*  mpirun -np 12 example-devel  -pc_type bjacobi -sub_pc_type ilu -sub_pc_factor_levels 4 -sub_pc_factor_zeropivot 0 -ksp_right_pc -log_summary
***************************************************************
</pre>
</div>
<?php make_footer() ?>
</body>
</html>
<?php if (0) { ?>
\#Local Variables:
\#mode: html
\#End:
<?php } ?>
